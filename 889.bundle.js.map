{"version":3,"file":"889.bundle.js","mappings":"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","sources":["webpack://card-deck/./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/localUniformBit.mjs","webpack://card-deck/./node_modules/pixi.js/lib/scene/text/canvas/BatchableText.mjs","webpack://card-deck/./node_modules/pixi.js/lib/scene/text/canvas/CanvasTextPipe.mjs","webpack://card-deck/./node_modules/pixi.js/lib/scene/text/canvas/CanvasTextSystem.mjs","webpack://card-deck/./node_modules/pixi.js/lib/scene/text/init.mjs","webpack://card-deck/./node_modules/pixi.js/lib/scene/text/utils/updateTextBounds.mjs","webpack://card-deck/./node_modules/pixi.js/lib/scene/text/utils/getPo2TextureFromSource.mjs","webpack://card-deck/./node_modules/pixi.js/lib/scene/text-html/BatchableHTMLText.mjs","webpack://card-deck/./node_modules/pixi.js/lib/scene/text-html/HTMLTextPipe.mjs","webpack://card-deck/./node_modules/pixi.js/lib/scene/text-html/HTMLTextRenderData.mjs","webpack://card-deck/./node_modules/pixi.js/lib/scene/text-html/utils/getFontCss.mjs","webpack://card-deck/./node_modules/pixi.js/lib/scene/text-html/utils/measureHtmlText.mjs","webpack://card-deck/./node_modules/pixi.js/lib/scene/text-html/HTMLTextSystem.mjs","webpack://card-deck/./node_modules/pixi.js/lib/scene/text-html/utils/extractFontFamilies.mjs","webpack://card-deck/./node_modules/pixi.js/lib/scene/text-html/utils/loadFontCSS.mjs","webpack://card-deck/./node_modules/pixi.js/lib/scene/text-html/utils/loadFontAsBase64.mjs","webpack://card-deck/./node_modules/pixi.js/lib/scene/text-html/utils/getSVGUrl.mjs","webpack://card-deck/./node_modules/pixi.js/lib/scene/text-html/utils/loadSVGImage.mjs","webpack://card-deck/./node_modules/pixi.js/lib/utils/browser/isSafari.mjs","webpack://card-deck/./node_modules/pixi.js/lib/scene/text-html/utils/getTemporaryCanvasFromImage.mjs","webpack://card-deck/./node_modules/pixi.js/lib/scene/text-html/init.mjs","webpack://card-deck/./node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.mjs","webpack://card-deck/./node_modules/pixi.js/lib/app/ResizePlugin.mjs","webpack://card-deck/./node_modules/pixi.js/lib/app/TickerPlugin.mjs","webpack://card-deck/./node_modules/pixi.js/lib/app/init.mjs","webpack://card-deck/./node_modules/pixi.js/lib/filters/FilterPipe.mjs","webpack://card-deck/./node_modules/pixi.js/lib/filters/FilterSystem.mjs","webpack://card-deck/./node_modules/pixi.js/lib/scene/container/bounds/getRenderableBounds.mjs","webpack://card-deck/./node_modules/pixi.js/lib/filters/init.mjs","webpack://card-deck/./node_modules/pixi.js/lib/scene/mesh/shared/MeshGeometry.mjs","webpack://card-deck/./node_modules/pixi.js/lib/scene/mesh/shared/MeshPipe.mjs","webpack://card-deck/./node_modules/pixi.js/lib/scene/mesh/init.mjs","webpack://card-deck/./node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/localUniformMSDFBit.mjs","webpack://card-deck/./node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/mSDFBit.mjs","webpack://card-deck/./node_modules/pixi.js/lib/scene/text/sdfShader/SdfShader.mjs","webpack://card-deck/./node_modules/pixi.js/lib/scene/text-bitmap/BitmapTextPipe.mjs","webpack://card-deck/./node_modules/pixi.js/lib/scene/text-bitmap/init.mjs","webpack://card-deck/./node_modules/pixi.js/lib/scene/mesh-plane/PlaneGeometry.mjs","webpack://card-deck/./node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceGeometry.mjs","webpack://card-deck/./node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceSpritePipe.mjs","webpack://card-deck/./node_modules/pixi.js/lib/scene/sprite-nine-slice/init.mjs","webpack://card-deck/./node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs","webpack://card-deck/./node_modules/pixi.js/lib/scene/sprite/BatchableSprite.mjs","webpack://card-deck/./node_modules/pixi.js/lib/scene/sprite-tiling/shader/tilingBit.mjs","webpack://card-deck/./node_modules/pixi.js/lib/scene/sprite-tiling/shader/TilingSpriteShader.mjs","webpack://card-deck/./node_modules/pixi.js/lib/scene/sprite-tiling/utils/QuadGeometry.mjs","webpack://card-deck/./node_modules/pixi.js/lib/scene/sprite-tiling/TilingSpritePipe.mjs","webpack://card-deck/./node_modules/pixi.js/lib/scene/sprite-tiling/utils/setUvs.mjs","webpack://card-deck/./node_modules/pixi.js/lib/scene/sprite-tiling/utils/applyMatrix.mjs","webpack://card-deck/./node_modules/pixi.js/lib/scene/sprite-tiling/utils/setPositions.mjs","webpack://card-deck/./node_modules/pixi.js/lib/scene/sprite-tiling/init.mjs","webpack://card-deck/./node_modules/pixi.js/lib/scene/mesh/shared/BatchableMesh.mjs","webpack://card-deck/./node_modules/pixi.js/lib/scene/graphics/shared/GraphicsPipe.mjs","webpack://card-deck/./node_modules/pixi.js/lib/scene/graphics/init.mjs","webpack://card-deck/./node_modules/pixi.js/lib/scene/particle-container/gl/GlParticleContainerAdaptor.mjs","webpack://card-deck/./node_modules/pixi.js/lib/scene/particle-container/shared/utils/createIndicesForQuads.mjs","webpack://card-deck/./node_modules/pixi.js/lib/scene/particle-container/shared/utils/generateParticleUpdateFunction.mjs","webpack://card-deck/./node_modules/pixi.js/lib/scene/particle-container/shared/ParticleBuffer.mjs","webpack://card-deck/./node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.wgsl.mjs","webpack://card-deck/./node_modules/pixi.js/lib/scene/particle-container/shared/shader/ParticleShader.mjs","webpack://card-deck/./node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.vert.mjs","webpack://card-deck/./node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.frag.mjs","webpack://card-deck/./node_modules/pixi.js/lib/scene/particle-container/shared/ParticleContainerPipe.mjs","webpack://card-deck/./node_modules/pixi.js/lib/scene/particle-container/shared/GlParticleContainerPipe.mjs","webpack://card-deck/./node_modules/pixi.js/lib/scene/particle-container/gpu/GpuParticleContainerAdaptor.mjs","webpack://card-deck/./node_modules/pixi.js/lib/scene/particle-container/shared/GpuParticleContainerPipe.mjs","webpack://card-deck/./node_modules/pixi.js/lib/scene/particle-container/init.mjs"],"sourcesContent":["\"use strict\";\nconst localUniformBit = {\n  name: \"local-uniform-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n\n            struct LocalUniforms {\n                uTransformMatrix:mat3x3<f32>,\n                uColor:vec4<f32>,\n                uRound:f32,\n            }\n\n            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `\n    ),\n    end: (\n      /* wgsl */\n      `\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    )\n  }\n};\nconst localUniformBitGroup2 = {\n  ...localUniformBit,\n  vertex: {\n    ...localUniformBit.vertex,\n    // replace the group!\n    header: localUniformBit.vertex.header.replace(\"group(1)\", \"group(2)\")\n  }\n};\nconst localUniformBitGl = {\n  name: \"local-uniform-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            vColor *= uColor;\n            modelMatrix = uTransformMatrix;\n        `\n    ),\n    end: (\n      /* glsl */\n      `\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    )\n  }\n};\n\nexport { localUniformBit, localUniformBitGl, localUniformBitGroup2 };\n//# sourceMappingURL=localUniformBit.mjs.map\n","import { BatchableSprite } from '../../sprite/BatchableSprite.mjs';\n\n\"use strict\";\nclass BatchableText extends BatchableSprite {\n  constructor(renderer) {\n    super();\n    this._renderer = renderer;\n    renderer.runners.resolutionChange.add(this);\n  }\n  resolutionChange() {\n    const text = this.renderable;\n    if (text._autoResolution) {\n      text.onViewUpdate();\n    }\n  }\n  destroy() {\n    this._renderer.canvasText.returnTexture(this.texture);\n    this._renderer = null;\n  }\n}\n\nexport { BatchableText };\n//# sourceMappingURL=BatchableText.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { updateTextBounds } from '../utils/updateTextBounds.mjs';\nimport { BatchableText } from './BatchableText.mjs';\n\n\"use strict\";\nclass CanvasTextPipe {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  validateRenderable(text) {\n    return text._didTextUpdate;\n  }\n  addRenderable(text, instructionSet) {\n    const batchableText = this._getGpuText(text);\n    if (text._didTextUpdate) {\n      this._updateGpuText(text);\n      text._didTextUpdate = false;\n    }\n    this._renderer.renderPipes.batch.addToBatch(batchableText, instructionSet);\n  }\n  updateRenderable(text) {\n    const batchableText = this._getGpuText(text);\n    batchableText._batcher.updateElement(batchableText);\n  }\n  _updateGpuText(text) {\n    const batchableText = this._getGpuText(text);\n    if (batchableText.texture) {\n      this._renderer.canvasText.returnTexture(batchableText.texture);\n    }\n    text._resolution = text._autoResolution ? this._renderer.resolution : text.resolution;\n    batchableText.texture = this._renderer.canvasText.getTexture(text);\n    updateTextBounds(batchableText, text);\n  }\n  _getGpuText(text) {\n    return text._gpuData[this._renderer.uid] || this.initGpuText(text);\n  }\n  initGpuText(text) {\n    const batchableText = new BatchableText(this._renderer);\n    batchableText.renderable = text;\n    batchableText.transform = text.groupTransform;\n    batchableText.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n    batchableText.roundPixels = this._renderer._roundPixels | text._roundPixels;\n    text._gpuData[this._renderer.uid] = batchableText;\n    return batchableText;\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\n/** @ignore */\nCanvasTextPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"text\"\n};\n\nexport { CanvasTextPipe };\n//# sourceMappingURL=CanvasTextPipe.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { TexturePool } from '../../../rendering/renderers/shared/texture/TexturePool.mjs';\nimport { TextureStyle } from '../../../rendering/renderers/shared/texture/TextureStyle.mjs';\nimport { deprecation } from '../../../utils/logging/deprecation.mjs';\nimport { TextStyle } from '../TextStyle.mjs';\nimport { getPo2TextureFromSource } from '../utils/getPo2TextureFromSource.mjs';\nimport { CanvasTextGenerator } from './CanvasTextGenerator.mjs';\n\n\"use strict\";\nclass CanvasTextSystem {\n  constructor(_renderer) {\n    this._renderer = _renderer;\n  }\n  getTexture(options, _resolution, _style, _textKey) {\n    if (typeof options === \"string\") {\n      deprecation(\"8.0.0\", \"CanvasTextSystem.getTexture: Use object TextOptions instead of separate arguments\");\n      options = {\n        text: options,\n        style: _style,\n        resolution: _resolution\n      };\n    }\n    if (!(options.style instanceof TextStyle)) {\n      options.style = new TextStyle(options.style);\n    }\n    if (!(options.textureStyle instanceof TextureStyle)) {\n      options.textureStyle = new TextureStyle(options.textureStyle);\n    }\n    if (typeof options.text !== \"string\") {\n      options.text = options.text.toString();\n    }\n    const { text, style, textureStyle } = options;\n    const resolution = options.resolution ?? this._renderer.resolution;\n    const { frame, canvasAndContext } = CanvasTextGenerator.getCanvasAndContext({\n      text,\n      style,\n      resolution\n    });\n    const texture = getPo2TextureFromSource(canvasAndContext.canvas, frame.width, frame.height, resolution);\n    if (textureStyle)\n      texture.source.style = textureStyle;\n    if (style.trim) {\n      frame.pad(style.padding);\n      texture.frame.copyFrom(frame);\n      texture.frame.scale(1 / resolution);\n      texture.updateUvs();\n    }\n    if (style.filters) {\n      const filteredTexture = this._applyFilters(texture, style.filters);\n      this.returnTexture(texture);\n      CanvasTextGenerator.returnCanvasAndContext(canvasAndContext);\n      return filteredTexture;\n    }\n    this._renderer.texture.initSource(texture._source);\n    CanvasTextGenerator.returnCanvasAndContext(canvasAndContext);\n    return texture;\n  }\n  /**\n   * Returns a texture that was created wit the above `getTexture` function.\n   * Handy if you are done with a texture and want to return it to the pool.\n   * @param texture - The texture to be returned.\n   */\n  returnTexture(texture) {\n    const source = texture.source;\n    source.resource = null;\n    source.uploadMethodId = \"unknown\";\n    source.alphaMode = \"no-premultiply-alpha\";\n    TexturePool.returnTexture(texture, true);\n  }\n  /**\n   * Renders text to its canvas, and updates its texture.\n   * @deprecated since 8.10.0\n   */\n  renderTextToCanvas() {\n    deprecation(\n      \"8.10.0\",\n      \"CanvasTextSystem.renderTextToCanvas: no longer supported, use CanvasTextSystem.getTexture instead\"\n    );\n  }\n  /**\n   * Applies the specified filters to the given texture.\n   *\n   * This method takes a texture and a list of filters, applies the filters to the texture,\n   * and returns the resulting texture. It also ensures that the alpha mode of the resulting\n   * texture is set to 'premultiplied-alpha'.\n   * @param {Texture} texture - The texture to which the filters will be applied.\n   * @param {Filter[]} filters - The filters to apply to the texture.\n   * @returns {Texture} The resulting texture after all filters have been applied.\n   */\n  _applyFilters(texture, filters) {\n    const currentRenderTarget = this._renderer.renderTarget.renderTarget;\n    const resultTexture = this._renderer.filter.generateFilteredTexture({\n      texture,\n      filters\n    });\n    this._renderer.renderTarget.bind(currentRenderTarget, false);\n    return resultTexture;\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\n/** @ignore */\nCanvasTextSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem,\n    ExtensionType.CanvasSystem\n  ],\n  name: \"canvasText\"\n};\n\nexport { CanvasTextSystem };\n//# sourceMappingURL=CanvasTextSystem.mjs.map\n","import { extensions } from '../../extensions/Extensions.mjs';\nimport { CanvasTextPipe } from './canvas/CanvasTextPipe.mjs';\nimport { CanvasTextSystem } from './canvas/CanvasTextSystem.mjs';\n\n\"use strict\";\nextensions.add(CanvasTextSystem);\nextensions.add(CanvasTextPipe);\n//# sourceMappingURL=init.mjs.map\n","import { updateQuadBounds } from '../../../utils/data/updateQuadBounds.mjs';\n\n\"use strict\";\nfunction updateTextBounds(batchableSprite, text) {\n  const { texture, bounds } = batchableSprite;\n  const padding = text._style._getFinalPadding();\n  updateQuadBounds(bounds, text._anchor, texture);\n  const paddingOffset = text._anchor._x * padding * 2;\n  const paddingOffsetY = text._anchor._y * padding * 2;\n  bounds.minX -= padding - paddingOffset;\n  bounds.minY -= padding - paddingOffsetY;\n  bounds.maxX -= padding - paddingOffset;\n  bounds.maxY -= padding - paddingOffsetY;\n}\n\nexport { updateTextBounds };\n//# sourceMappingURL=updateTextBounds.mjs.map\n","import { TexturePool } from '../../../rendering/renderers/shared/texture/TexturePool.mjs';\nimport { Bounds } from '../../container/bounds/Bounds.mjs';\n\n\"use strict\";\nconst tempBounds = new Bounds();\nfunction getPo2TextureFromSource(image, width, height, resolution) {\n  const bounds = tempBounds;\n  bounds.minX = 0;\n  bounds.minY = 0;\n  bounds.maxX = image.width / resolution | 0;\n  bounds.maxY = image.height / resolution | 0;\n  const texture = TexturePool.getOptimalTexture(\n    bounds.width,\n    bounds.height,\n    resolution,\n    false\n  );\n  texture.source.uploadMethodId = \"image\";\n  texture.source.resource = image;\n  texture.source.alphaMode = \"premultiply-alpha-on-upload\";\n  texture.frame.width = width / resolution;\n  texture.frame.height = height / resolution;\n  texture.source.emit(\"update\", texture.source);\n  texture.updateUvs();\n  return texture;\n}\n\nexport { getPo2TextureFromSource };\n//# sourceMappingURL=getPo2TextureFromSource.mjs.map\n","import { BatchableSprite } from '../sprite/BatchableSprite.mjs';\n\n\"use strict\";\nclass BatchableHTMLText extends BatchableSprite {\n  /**\n   * Creates an instance of BatchableHTMLText.\n   * @param renderer - The renderer instance to be used.\n   */\n  constructor(renderer) {\n    super();\n    this.generatingTexture = false;\n    this._renderer = renderer;\n    renderer.runners.resolutionChange.add(this);\n  }\n  /** Handles resolution changes for the HTML text. If the text has auto resolution enabled, it triggers a view update. */\n  resolutionChange() {\n    const text = this.renderable;\n    if (text._autoResolution) {\n      text.onViewUpdate();\n    }\n  }\n  /** Destroys the BatchableHTMLText instance. Returns the texture promise to the renderer and cleans up references. */\n  destroy() {\n    this._renderer.htmlText.returnTexturePromise(this.texturePromise);\n    this.texturePromise = null;\n    this._renderer = null;\n  }\n}\n\nexport { BatchableHTMLText };\n//# sourceMappingURL=BatchableHTMLText.mjs.map\n","import { ExtensionType } from '../../extensions/Extensions.mjs';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture.mjs';\nimport { updateTextBounds } from '../text/utils/updateTextBounds.mjs';\nimport { BatchableHTMLText } from './BatchableHTMLText.mjs';\n\n\"use strict\";\nclass HTMLTextPipe {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  validateRenderable(htmlText) {\n    return htmlText._didTextUpdate;\n  }\n  addRenderable(htmlText, instructionSet) {\n    const batchableHTMLText = this._getGpuText(htmlText);\n    if (htmlText._didTextUpdate) {\n      this._updateGpuText(htmlText).catch((e) => {\n        console.error(e);\n      });\n      htmlText._didTextUpdate = false;\n      updateTextBounds(batchableHTMLText, htmlText);\n    }\n    this._renderer.renderPipes.batch.addToBatch(batchableHTMLText, instructionSet);\n  }\n  updateRenderable(htmlText) {\n    const batchableHTMLText = this._getGpuText(htmlText);\n    batchableHTMLText._batcher.updateElement(batchableHTMLText);\n  }\n  async _updateGpuText(htmlText) {\n    htmlText._didTextUpdate = false;\n    const batchableHTMLText = this._getGpuText(htmlText);\n    if (batchableHTMLText.generatingTexture)\n      return;\n    if (batchableHTMLText.texturePromise) {\n      this._renderer.htmlText.returnTexturePromise(batchableHTMLText.texturePromise);\n      batchableHTMLText.texturePromise = null;\n    }\n    batchableHTMLText.generatingTexture = true;\n    htmlText._resolution = htmlText._autoResolution ? this._renderer.resolution : htmlText.resolution;\n    const texturePromise = this._renderer.htmlText.getTexturePromise(htmlText);\n    batchableHTMLText.texturePromise = texturePromise;\n    batchableHTMLText.texture = await texturePromise;\n    const renderGroup = htmlText.renderGroup || htmlText.parentRenderGroup;\n    if (renderGroup) {\n      renderGroup.structureDidChange = true;\n    }\n    batchableHTMLText.generatingTexture = false;\n    updateTextBounds(batchableHTMLText, htmlText);\n  }\n  _getGpuText(htmlText) {\n    return htmlText._gpuData[this._renderer.uid] || this.initGpuText(htmlText);\n  }\n  initGpuText(htmlText) {\n    const batchableHTMLText = new BatchableHTMLText(this._renderer);\n    batchableHTMLText.renderable = htmlText;\n    batchableHTMLText.transform = htmlText.groupTransform;\n    batchableHTMLText.texture = Texture.EMPTY;\n    batchableHTMLText.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n    batchableHTMLText.roundPixels = this._renderer._roundPixels | htmlText._roundPixels;\n    htmlText._resolution = htmlText._autoResolution ? this._renderer.resolution : htmlText.resolution;\n    htmlText._gpuData[this._renderer.uid] = batchableHTMLText;\n    return batchableHTMLText;\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\n/** @ignore */\nHTMLTextPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"htmlText\"\n};\n\nexport { HTMLTextPipe };\n//# sourceMappingURL=HTMLTextPipe.mjs.map\n","import { DOMAdapter } from '../../environment/adapter.mjs';\n\n\"use strict\";\nconst nssvg = \"http://www.w3.org/2000/svg\";\nconst nsxhtml = \"http://www.w3.org/1999/xhtml\";\nclass HTMLTextRenderData {\n  constructor() {\n    this.svgRoot = document.createElementNS(nssvg, \"svg\");\n    this.foreignObject = document.createElementNS(nssvg, \"foreignObject\");\n    this.domElement = document.createElementNS(nsxhtml, \"div\");\n    this.styleElement = document.createElementNS(nsxhtml, \"style\");\n    const { foreignObject, svgRoot, styleElement, domElement } = this;\n    foreignObject.setAttribute(\"width\", \"10000\");\n    foreignObject.setAttribute(\"height\", \"10000\");\n    foreignObject.style.overflow = \"hidden\";\n    svgRoot.appendChild(foreignObject);\n    foreignObject.appendChild(styleElement);\n    foreignObject.appendChild(domElement);\n    this.image = DOMAdapter.get().createImage();\n  }\n}\n\nexport { HTMLTextRenderData };\n//# sourceMappingURL=HTMLTextRenderData.mjs.map\n","import { Cache } from '../../../assets/cache/Cache.mjs';\nimport { loadFontCSS } from './loadFontCSS.mjs';\n\n\"use strict\";\nconst FontStylePromiseCache = /* @__PURE__ */ new Map();\nasync function getFontCss(fontFamilies) {\n  const fontPromises = fontFamilies.filter((fontFamily) => Cache.has(`${fontFamily}-and-url`)).map((fontFamily) => {\n    if (!FontStylePromiseCache.has(fontFamily)) {\n      const { entries } = Cache.get(`${fontFamily}-and-url`);\n      const promises = [];\n      entries.forEach((entry) => {\n        const url = entry.url;\n        const faces = entry.faces;\n        const out = faces.map((face) => ({ weight: face.weight, style: face.style }));\n        promises.push(\n          ...out.map(\n            (style) => loadFontCSS(\n              {\n                fontWeight: style.weight,\n                fontStyle: style.style,\n                fontFamily\n              },\n              url\n            )\n          )\n        );\n      });\n      FontStylePromiseCache.set(\n        fontFamily,\n        Promise.all(promises).then((css) => css.join(\"\\n\"))\n      );\n    }\n    return FontStylePromiseCache.get(fontFamily);\n  });\n  return (await Promise.all(fontPromises)).join(\"\\n\");\n}\n\nexport { FontStylePromiseCache, getFontCss };\n//# sourceMappingURL=getFontCss.mjs.map\n","import { HTMLTextRenderData } from '../HTMLTextRenderData.mjs';\n\n\"use strict\";\nlet tempHTMLTextRenderData;\nfunction measureHtmlText(text, style, fontStyleCSS, htmlTextRenderData) {\n  htmlTextRenderData || (htmlTextRenderData = tempHTMLTextRenderData || (tempHTMLTextRenderData = new HTMLTextRenderData()));\n  const { domElement, styleElement, svgRoot } = htmlTextRenderData;\n  domElement.innerHTML = `<style>${style.cssStyle};</style><div style='padding:0'>${text}</div>`;\n  domElement.setAttribute(\"style\", \"transform-origin: top left; display: inline-block\");\n  if (fontStyleCSS) {\n    styleElement.textContent = fontStyleCSS;\n  }\n  document.body.appendChild(svgRoot);\n  const contentBounds = domElement.getBoundingClientRect();\n  svgRoot.remove();\n  const doublePadding = style.padding * 2;\n  return {\n    width: contentBounds.width - doublePadding,\n    height: contentBounds.height - doublePadding\n  };\n}\n\nexport { measureHtmlText };\n//# sourceMappingURL=measureHtmlText.mjs.map\n","import { ExtensionType } from '../../extensions/Extensions.mjs';\nimport { CanvasPool } from '../../rendering/renderers/shared/texture/CanvasPool.mjs';\nimport { TexturePool } from '../../rendering/renderers/shared/texture/TexturePool.mjs';\nimport { RendererType } from '../../rendering/renderers/types.mjs';\nimport { isSafari } from '../../utils/browser/isSafari.mjs';\nimport { warn } from '../../utils/logging/warn.mjs';\nimport { BigPool } from '../../utils/pool/PoolGroup.mjs';\nimport { getPo2TextureFromSource } from '../text/utils/getPo2TextureFromSource.mjs';\nimport { HTMLTextRenderData } from './HTMLTextRenderData.mjs';\nimport { extractFontFamilies } from './utils/extractFontFamilies.mjs';\nimport { getFontCss } from './utils/getFontCss.mjs';\nimport { getSVGUrl } from './utils/getSVGUrl.mjs';\nimport { getTemporaryCanvasFromImage } from './utils/getTemporaryCanvasFromImage.mjs';\nimport { loadSVGImage } from './utils/loadSVGImage.mjs';\nimport { measureHtmlText } from './utils/measureHtmlText.mjs';\n\n\"use strict\";\nclass HTMLTextSystem {\n  constructor(renderer) {\n    this._renderer = renderer;\n    this._createCanvas = renderer.type === RendererType.WEBGPU;\n  }\n  /**\n   * @param options\n   * @deprecated Use getTexturePromise instead\n   */\n  getTexture(options) {\n    return this.getTexturePromise(options);\n  }\n  getTexturePromise(options) {\n    return this._buildTexturePromise(options);\n  }\n  async _buildTexturePromise(options) {\n    const { text, style, resolution, textureStyle } = options;\n    const htmlTextData = BigPool.get(HTMLTextRenderData);\n    const fontFamilies = extractFontFamilies(text, style);\n    const fontCSS = await getFontCss(fontFamilies);\n    const measured = measureHtmlText(text, style, fontCSS, htmlTextData);\n    const width = Math.ceil(Math.ceil(Math.max(1, measured.width) + style.padding * 2) * resolution);\n    const height = Math.ceil(Math.ceil(Math.max(1, measured.height) + style.padding * 2) * resolution);\n    const image = htmlTextData.image;\n    const uvSafeOffset = 2;\n    image.width = (width | 0) + uvSafeOffset;\n    image.height = (height | 0) + uvSafeOffset;\n    const svgURL = getSVGUrl(text, style, resolution, fontCSS, htmlTextData);\n    await loadSVGImage(image, svgURL, isSafari() && fontFamilies.length > 0);\n    const resource = image;\n    let canvasAndContext;\n    if (this._createCanvas) {\n      canvasAndContext = getTemporaryCanvasFromImage(image, resolution);\n    }\n    const texture = getPo2TextureFromSource(\n      canvasAndContext ? canvasAndContext.canvas : resource,\n      image.width - uvSafeOffset,\n      image.height - uvSafeOffset,\n      resolution\n    );\n    if (textureStyle)\n      texture.source.style = textureStyle;\n    if (this._createCanvas) {\n      this._renderer.texture.initSource(texture.source);\n      CanvasPool.returnCanvasAndContext(canvasAndContext);\n    }\n    BigPool.return(htmlTextData);\n    return texture;\n  }\n  returnTexturePromise(texturePromise) {\n    texturePromise.then((texture) => {\n      this._cleanUp(texture);\n    }).catch(() => {\n      warn(\"HTMLTextSystem: Failed to clean texture\");\n    });\n  }\n  _cleanUp(texture) {\n    TexturePool.returnTexture(texture, true);\n    texture.source.resource = null;\n    texture.source.uploadMethodId = \"unknown\";\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\n/** @ignore */\nHTMLTextSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem,\n    ExtensionType.CanvasSystem\n  ],\n  name: \"htmlText\"\n};\n\nexport { HTMLTextSystem };\n//# sourceMappingURL=HTMLTextSystem.mjs.map\n","\"use strict\";\nfunction extractFontFamilies(text, style) {\n  const fontFamily = style.fontFamily;\n  const fontFamilies = [];\n  const dedupe = {};\n  const regex = /font-family:([^;\"\\s]+)/g;\n  const matches = text.match(regex);\n  function addFontFamily(fontFamily2) {\n    if (!dedupe[fontFamily2]) {\n      fontFamilies.push(fontFamily2);\n      dedupe[fontFamily2] = true;\n    }\n  }\n  if (Array.isArray(fontFamily)) {\n    for (let i = 0; i < fontFamily.length; i++) {\n      addFontFamily(fontFamily[i]);\n    }\n  } else {\n    addFontFamily(fontFamily);\n  }\n  if (matches) {\n    matches.forEach((match) => {\n      const fontFamily2 = match.split(\":\")[1].trim();\n      addFontFamily(fontFamily2);\n    });\n  }\n  for (const i in style.tagStyles) {\n    const fontFamily2 = style.tagStyles[i].fontFamily;\n    addFontFamily(fontFamily2);\n  }\n  return fontFamilies;\n}\n\nexport { extractFontFamilies };\n//# sourceMappingURL=extractFontFamilies.mjs.map\n","import { loadFontAsBase64 } from './loadFontAsBase64.mjs';\n\n\"use strict\";\nasync function loadFontCSS(style, url) {\n  const dataSrc = await loadFontAsBase64(url);\n  return `@font-face {\n        font-family: \"${style.fontFamily}\";\n        font-weight: ${style.fontWeight};\n        font-style: ${style.fontStyle};\n        src: url('${dataSrc}');\n    }`;\n}\n\nexport { loadFontCSS };\n//# sourceMappingURL=loadFontCSS.mjs.map\n","import { DOMAdapter } from '../../../environment/adapter.mjs';\n\n\"use strict\";\nasync function loadFontAsBase64(url) {\n  const response = await DOMAdapter.get().fetch(url);\n  const blob = await response.blob();\n  const reader = new FileReader();\n  const dataSrc = await new Promise((resolve, reject) => {\n    reader.onloadend = () => resolve(reader.result);\n    reader.onerror = reject;\n    reader.readAsDataURL(blob);\n  });\n  return dataSrc;\n}\n\nexport { loadFontAsBase64 };\n//# sourceMappingURL=loadFontAsBase64.mjs.map\n","\"use strict\";\nfunction getSVGUrl(text, style, resolution, fontCSS, htmlTextData) {\n  const { domElement, styleElement, svgRoot } = htmlTextData;\n  domElement.innerHTML = `<style>${style.cssStyle}</style><div style='padding:0;'>${text}</div>`;\n  domElement.setAttribute(\"style\", `transform: scale(${resolution});transform-origin: top left; display: inline-block`);\n  styleElement.textContent = fontCSS;\n  const { width, height } = htmlTextData.image;\n  svgRoot.setAttribute(\"width\", width.toString());\n  svgRoot.setAttribute(\"height\", height.toString());\n  return new XMLSerializer().serializeToString(svgRoot);\n}\n\nexport { getSVGUrl };\n//# sourceMappingURL=getSVGUrl.mjs.map\n","\"use strict\";\nfunction loadSVGImage(image, url, delay) {\n  return new Promise(async (resolve) => {\n    if (delay) {\n      await new Promise((resolve2) => setTimeout(resolve2, 100));\n    }\n    image.onload = () => {\n      resolve();\n    };\n    image.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(url)}`;\n    image.crossOrigin = \"anonymous\";\n  });\n}\n\nexport { loadSVGImage };\n//# sourceMappingURL=loadSVGImage.mjs.map\n","import { DOMAdapter } from '../../environment/adapter.mjs';\n\n\"use strict\";\nfunction isSafari() {\n  const { userAgent } = DOMAdapter.get().getNavigator();\n  return /^((?!chrome|android).)*safari/i.test(userAgent);\n}\n\nexport { isSafari };\n//# sourceMappingURL=isSafari.mjs.map\n","import { CanvasPool } from '../../../rendering/renderers/shared/texture/CanvasPool.mjs';\n\n\"use strict\";\nfunction getTemporaryCanvasFromImage(image, resolution) {\n  const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(\n    image.width,\n    image.height,\n    resolution\n  );\n  const { context } = canvasAndContext;\n  context.clearRect(0, 0, image.width, image.height);\n  context.drawImage(image, 0, 0);\n  return canvasAndContext;\n}\n\nexport { getTemporaryCanvasFromImage };\n//# sourceMappingURL=getTemporaryCanvasFromImage.mjs.map\n","import { extensions } from '../../extensions/Extensions.mjs';\nimport { HTMLTextPipe } from './HTMLTextPipe.mjs';\nimport { HTMLTextSystem } from './HTMLTextSystem.mjs';\n\n\"use strict\";\nextensions.add(HTMLTextSystem);\nextensions.add(HTMLTextPipe);\n//# sourceMappingURL=init.mjs.map\n","\"use strict\";\nfunction colorToUniform(rgb, alpha, out, offset) {\n  out[offset++] = (rgb >> 16 & 255) / 255;\n  out[offset++] = (rgb >> 8 & 255) / 255;\n  out[offset++] = (rgb & 255) / 255;\n  out[offset++] = alpha;\n}\nfunction color32BitToUniform(abgr, out, offset) {\n  const alpha = (abgr >> 24 & 255) / 255;\n  out[offset++] = (abgr & 255) / 255 * alpha;\n  out[offset++] = (abgr >> 8 & 255) / 255 * alpha;\n  out[offset++] = (abgr >> 16 & 255) / 255 * alpha;\n  out[offset++] = alpha;\n}\n\nexport { color32BitToUniform, colorToUniform };\n//# sourceMappingURL=colorToUniform.mjs.map\n","import { ExtensionType } from '../extensions/Extensions.mjs';\n\n\"use strict\";\nclass ResizePlugin {\n  /**\n   * Initialize the plugin with scope of application instance\n   * @private\n   * @param {object} [options] - See application options\n   */\n  static init(options) {\n    Object.defineProperty(\n      this,\n      \"resizeTo\",\n      {\n        set(dom) {\n          globalThis.removeEventListener(\"resize\", this.queueResize);\n          this._resizeTo = dom;\n          if (dom) {\n            globalThis.addEventListener(\"resize\", this.queueResize);\n            this.resize();\n          }\n        },\n        get() {\n          return this._resizeTo;\n        }\n      }\n    );\n    this.queueResize = () => {\n      if (!this._resizeTo) {\n        return;\n      }\n      this._cancelResize();\n      this._resizeId = requestAnimationFrame(() => this.resize());\n    };\n    this._cancelResize = () => {\n      if (this._resizeId) {\n        cancelAnimationFrame(this._resizeId);\n        this._resizeId = null;\n      }\n    };\n    this.resize = () => {\n      if (!this._resizeTo) {\n        return;\n      }\n      this._cancelResize();\n      let width;\n      let height;\n      if (this._resizeTo === globalThis.window) {\n        width = globalThis.innerWidth;\n        height = globalThis.innerHeight;\n      } else {\n        const { clientWidth, clientHeight } = this._resizeTo;\n        width = clientWidth;\n        height = clientHeight;\n      }\n      this.renderer.resize(width, height);\n      this.render();\n    };\n    this._resizeId = null;\n    this._resizeTo = null;\n    this.resizeTo = options.resizeTo || null;\n  }\n  /**\n   * Clean up the ticker, scoped to application\n   * @private\n   */\n  static destroy() {\n    globalThis.removeEventListener(\"resize\", this.queueResize);\n    this._cancelResize();\n    this._cancelResize = null;\n    this.queueResize = null;\n    this.resizeTo = null;\n    this.resize = null;\n  }\n}\n/** @ignore */\nResizePlugin.extension = ExtensionType.Application;\n\nexport { ResizePlugin };\n//# sourceMappingURL=ResizePlugin.mjs.map\n","import { ExtensionType } from '../extensions/Extensions.mjs';\nimport { UPDATE_PRIORITY } from '../ticker/const.mjs';\nimport { Ticker } from '../ticker/Ticker.mjs';\n\n\"use strict\";\nclass TickerPlugin {\n  /**\n   * Initialize the plugin with scope of application instance\n   * @private\n   * @param {object} [options] - See application options\n   */\n  static init(options) {\n    options = Object.assign({\n      autoStart: true,\n      sharedTicker: false\n    }, options);\n    Object.defineProperty(\n      this,\n      \"ticker\",\n      {\n        set(ticker) {\n          if (this._ticker) {\n            this._ticker.remove(this.render, this);\n          }\n          this._ticker = ticker;\n          if (ticker) {\n            ticker.add(this.render, this, UPDATE_PRIORITY.LOW);\n          }\n        },\n        get() {\n          return this._ticker;\n        }\n      }\n    );\n    this.stop = () => {\n      this._ticker.stop();\n    };\n    this.start = () => {\n      this._ticker.start();\n    };\n    this._ticker = null;\n    this.ticker = options.sharedTicker ? Ticker.shared : new Ticker();\n    if (options.autoStart) {\n      this.start();\n    }\n  }\n  /**\n   * Clean up the ticker, scoped to application.\n   * @private\n   */\n  static destroy() {\n    if (this._ticker) {\n      const oldTicker = this._ticker;\n      this.ticker = null;\n      oldTicker.destroy();\n    }\n  }\n}\n/** @ignore */\nTickerPlugin.extension = ExtensionType.Application;\n\nexport { TickerPlugin };\n//# sourceMappingURL=TickerPlugin.mjs.map\n","import { extensions } from '../extensions/Extensions.mjs';\nimport { ResizePlugin } from './ResizePlugin.mjs';\nimport { TickerPlugin } from './TickerPlugin.mjs';\n\n\"use strict\";\nextensions.add(ResizePlugin);\nextensions.add(TickerPlugin);\n//# sourceMappingURL=init.mjs.map\n","import { ExtensionType } from '../extensions/Extensions.mjs';\n\n\"use strict\";\nclass FilterPipe {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  push(filterEffect, container, instructionSet) {\n    const renderPipes = this._renderer.renderPipes;\n    renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: \"filter\",\n      canBundle: false,\n      action: \"pushFilter\",\n      container,\n      filterEffect\n    });\n  }\n  pop(_filterEffect, _container, instructionSet) {\n    this._renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: \"filter\",\n      action: \"popFilter\",\n      canBundle: false\n    });\n  }\n  execute(instruction) {\n    if (instruction.action === \"pushFilter\") {\n      this._renderer.filter.push(instruction);\n    } else if (instruction.action === \"popFilter\") {\n      this._renderer.filter.pop();\n    }\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\nFilterPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"filter\"\n};\n\nexport { FilterPipe };\n//# sourceMappingURL=FilterPipe.mjs.map\n","import { ExtensionType } from '../extensions/Extensions.mjs';\nimport { Matrix } from '../maths/matrix/Matrix.mjs';\nimport { BindGroup } from '../rendering/renderers/gpu/shader/BindGroup.mjs';\nimport { Geometry } from '../rendering/renderers/shared/geometry/Geometry.mjs';\nimport { UniformGroup } from '../rendering/renderers/shared/shader/UniformGroup.mjs';\nimport { Texture } from '../rendering/renderers/shared/texture/Texture.mjs';\nimport { TexturePool } from '../rendering/renderers/shared/texture/TexturePool.mjs';\nimport { RendererType } from '../rendering/renderers/types.mjs';\nimport { Bounds } from '../scene/container/bounds/Bounds.mjs';\nimport { getGlobalRenderableBounds } from '../scene/container/bounds/getRenderableBounds.mjs';\nimport { warn } from '../utils/logging/warn.mjs';\n\n\"use strict\";\nconst quadGeometry = new Geometry({\n  attributes: {\n    aPosition: {\n      buffer: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n      format: \"float32x2\",\n      stride: 2 * 4,\n      offset: 0\n    }\n  },\n  indexBuffer: new Uint32Array([0, 1, 2, 0, 2, 3])\n});\nclass FilterData {\n  constructor() {\n    /**\n     * Indicates whether the filter should be skipped.\n     * @type {boolean}\n     */\n    this.skip = false;\n    /**\n     * The texture to which the filter is applied.\n     * @type {Texture}\n     */\n    this.inputTexture = null;\n    /**\n     * The back texture used for blending, if required.\n     * @type {Texture | null}\n     */\n    this.backTexture = null;\n    /**\n     * The list of filters to be applied.\n     * @type {Filter[]}\n     */\n    this.filters = null;\n    /**\n     * The bounds of the filter area.\n     * @type {Bounds}\n     */\n    this.bounds = new Bounds();\n    /**\n     * The container to which the filter is applied.\n     * @type {Container}\n     */\n    this.container = null;\n    /**\n     * Indicates whether blending is required for the filter.\n     * @type {boolean}\n     */\n    this.blendRequired = false;\n    /**\n     * The render surface where the output of the filter is rendered.\n     * @type {RenderSurface}\n     */\n    this.outputRenderSurface = null;\n    /**\n     * The global frame of the filter area.\n     * @type {{ x: number, y: number, width: number, height: number }}\n     */\n    this.globalFrame = { x: 0, y: 0, width: 0, height: 0 };\n  }\n}\nclass FilterSystem {\n  constructor(renderer) {\n    this._filterStackIndex = 0;\n    this._filterStack = [];\n    this._filterGlobalUniforms = new UniformGroup({\n      uInputSize: { value: new Float32Array(4), type: \"vec4<f32>\" },\n      uInputPixel: { value: new Float32Array(4), type: \"vec4<f32>\" },\n      uInputClamp: { value: new Float32Array(4), type: \"vec4<f32>\" },\n      uOutputFrame: { value: new Float32Array(4), type: \"vec4<f32>\" },\n      uGlobalFrame: { value: new Float32Array(4), type: \"vec4<f32>\" },\n      uOutputTexture: { value: new Float32Array(4), type: \"vec4<f32>\" }\n    });\n    this._globalFilterBindGroup = new BindGroup({});\n    this.renderer = renderer;\n  }\n  /**\n   * The back texture of the currently active filter. Requires the filter to have `blendRequired` set to true.\n   * @readonly\n   */\n  get activeBackTexture() {\n    return this._activeFilterData?.backTexture;\n  }\n  /**\n   * Pushes a filter instruction onto the filter stack.\n   * @param instruction - The instruction containing the filter effect and container.\n   * @internal\n   */\n  push(instruction) {\n    const renderer = this.renderer;\n    const filters = instruction.filterEffect.filters;\n    const filterData = this._pushFilterData();\n    filterData.skip = false;\n    filterData.filters = filters;\n    filterData.container = instruction.container;\n    filterData.outputRenderSurface = renderer.renderTarget.renderSurface;\n    const colorTextureSource = renderer.renderTarget.renderTarget.colorTexture.source;\n    const rootResolution = colorTextureSource.resolution;\n    const rootAntialias = colorTextureSource.antialias;\n    if (filters.length === 0) {\n      filterData.skip = true;\n      return;\n    }\n    const bounds = filterData.bounds;\n    this._calculateFilterArea(instruction, bounds);\n    this._calculateFilterBounds(filterData, renderer.renderTarget.rootViewPort, rootAntialias, rootResolution, 1);\n    if (filterData.skip) {\n      return;\n    }\n    const previousFilterData = this._getPreviousFilterData();\n    const globalResolution = this._findFilterResolution(rootResolution);\n    let offsetX = 0;\n    let offsetY = 0;\n    if (previousFilterData) {\n      offsetX = previousFilterData.bounds.minX;\n      offsetY = previousFilterData.bounds.minY;\n    }\n    this._calculateGlobalFrame(\n      filterData,\n      offsetX,\n      offsetY,\n      globalResolution,\n      colorTextureSource.width,\n      colorTextureSource.height\n    );\n    this._setupFilterTextures(filterData, bounds, renderer, previousFilterData);\n  }\n  /**\n   * Applies filters to a texture.\n   *\n   * This method takes a texture and a list of filters, applies the filters to the texture,\n   * and returns the resulting texture.\n   * @param {object} params - The parameters for applying filters.\n   * @param {Texture} params.texture - The texture to apply filters to.\n   * @param {Filter[]} params.filters - The filters to apply.\n   * @returns {Texture} The resulting texture after all filters have been applied.\n   * @example\n   *\n   * ```ts\n   * // Create a texture and a list of filters\n   * const texture = new Texture(...);\n   * const filters = [new BlurFilter(), new ColorMatrixFilter()];\n   *\n   * // Apply the filters to the texture\n   * const resultTexture = filterSystem.applyToTexture({ texture, filters });\n   *\n   * // Use the resulting texture\n   * sprite.texture = resultTexture;\n   * ```\n   *\n   * Key Points:\n   * 1. padding is not currently supported here - so clipping may occur with filters that use padding.\n   * 2. If all filters are disabled or skipped, the original texture is returned.\n   */\n  generateFilteredTexture({ texture, filters }) {\n    const filterData = this._pushFilterData();\n    this._activeFilterData = filterData;\n    filterData.skip = false;\n    filterData.filters = filters;\n    const colorTextureSource = texture.source;\n    const rootResolution = colorTextureSource.resolution;\n    const rootAntialias = colorTextureSource.antialias;\n    if (filters.length === 0) {\n      filterData.skip = true;\n      return texture;\n    }\n    const bounds = filterData.bounds;\n    bounds.addRect(texture.frame);\n    this._calculateFilterBounds(filterData, bounds.rectangle, rootAntialias, rootResolution, 0);\n    if (filterData.skip) {\n      return texture;\n    }\n    const globalResolution = rootResolution;\n    const offsetX = 0;\n    const offsetY = 0;\n    this._calculateGlobalFrame(\n      filterData,\n      offsetX,\n      offsetY,\n      globalResolution,\n      colorTextureSource.width,\n      colorTextureSource.height\n    );\n    filterData.outputRenderSurface = TexturePool.getOptimalTexture(\n      bounds.width,\n      bounds.height,\n      filterData.resolution,\n      filterData.antialias\n    );\n    filterData.backTexture = Texture.EMPTY;\n    filterData.inputTexture = texture;\n    const renderer = this.renderer;\n    renderer.renderTarget.finishRenderPass();\n    this._applyFiltersToTexture(filterData, true);\n    const outputTexture = filterData.outputRenderSurface;\n    outputTexture.source.alphaMode = \"premultiplied-alpha\";\n    return outputTexture;\n  }\n  /** @internal */\n  pop() {\n    const renderer = this.renderer;\n    const filterData = this._popFilterData();\n    if (filterData.skip) {\n      return;\n    }\n    renderer.globalUniforms.pop();\n    renderer.renderTarget.finishRenderPass();\n    this._activeFilterData = filterData;\n    this._applyFiltersToTexture(filterData, false);\n    if (filterData.blendRequired) {\n      TexturePool.returnTexture(filterData.backTexture);\n    }\n    TexturePool.returnTexture(filterData.inputTexture);\n  }\n  /**\n   * Copies the last render surface to a texture.\n   * @param lastRenderSurface - The last render surface to copy from.\n   * @param bounds - The bounds of the area to copy.\n   * @param previousBounds - The previous bounds to use for offsetting the copy.\n   */\n  getBackTexture(lastRenderSurface, bounds, previousBounds) {\n    const backgroundResolution = lastRenderSurface.colorTexture.source._resolution;\n    const backTexture = TexturePool.getOptimalTexture(\n      bounds.width,\n      bounds.height,\n      backgroundResolution,\n      false\n    );\n    let x = bounds.minX;\n    let y = bounds.minY;\n    if (previousBounds) {\n      x -= previousBounds.minX;\n      y -= previousBounds.minY;\n    }\n    x = Math.floor(x * backgroundResolution);\n    y = Math.floor(y * backgroundResolution);\n    const width = Math.ceil(bounds.width * backgroundResolution);\n    const height = Math.ceil(bounds.height * backgroundResolution);\n    this.renderer.renderTarget.copyToTexture(\n      lastRenderSurface,\n      backTexture,\n      { x, y },\n      { width, height },\n      { x: 0, y: 0 }\n    );\n    return backTexture;\n  }\n  /**\n   * Applies a filter to a texture.\n   * @param filter - The filter to apply.\n   * @param input - The input texture.\n   * @param output - The output render surface.\n   * @param clear - Whether to clear the output surface before applying the filter.\n   */\n  applyFilter(filter, input, output, clear) {\n    const renderer = this.renderer;\n    const filterData = this._activeFilterData;\n    const outputRenderSurface = filterData.outputRenderSurface;\n    const isFinalTarget = outputRenderSurface === output;\n    const rootResolution = renderer.renderTarget.rootRenderTarget.colorTexture.source._resolution;\n    const resolution = this._findFilterResolution(rootResolution);\n    let offsetX = 0;\n    let offsetY = 0;\n    if (isFinalTarget) {\n      const offset = this._findPreviousFilterOffset();\n      offsetX = offset.x;\n      offsetY = offset.y;\n    }\n    this._updateFilterUniforms(input, output, filterData, offsetX, offsetY, resolution, isFinalTarget, clear);\n    this._setupBindGroupsAndRender(filter, input, renderer);\n  }\n  /**\n   * Multiply _input normalized coordinates_ to this matrix to get _sprite texture normalized coordinates_.\n   *\n   * Use `outputMatrix * vTextureCoord` in the shader.\n   * @param outputMatrix - The matrix to output to.\n   * @param {Sprite} sprite - The sprite to map to.\n   * @returns The mapped matrix.\n   */\n  calculateSpriteMatrix(outputMatrix, sprite) {\n    const data = this._activeFilterData;\n    const mappedMatrix = outputMatrix.set(\n      data.inputTexture._source.width,\n      0,\n      0,\n      data.inputTexture._source.height,\n      data.bounds.minX,\n      data.bounds.minY\n    );\n    const worldTransform = sprite.worldTransform.copyTo(Matrix.shared);\n    const renderGroup = sprite.renderGroup || sprite.parentRenderGroup;\n    if (renderGroup && renderGroup.cacheToLocalTransform) {\n      worldTransform.prepend(renderGroup.cacheToLocalTransform);\n    }\n    worldTransform.invert();\n    mappedMatrix.prepend(worldTransform);\n    mappedMatrix.scale(\n      1 / sprite.texture.orig.width,\n      1 / sprite.texture.orig.height\n    );\n    mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);\n    return mappedMatrix;\n  }\n  destroy() {\n  }\n  /**\n   * Sets up the bind groups and renders the filter.\n   * @param filter - The filter to apply\n   * @param input - The input texture\n   * @param renderer - The renderer instance\n   */\n  _setupBindGroupsAndRender(filter, input, renderer) {\n    if (renderer.renderPipes.uniformBatch) {\n      const batchUniforms = renderer.renderPipes.uniformBatch.getUboResource(this._filterGlobalUniforms);\n      this._globalFilterBindGroup.setResource(batchUniforms, 0);\n    } else {\n      this._globalFilterBindGroup.setResource(this._filterGlobalUniforms, 0);\n    }\n    this._globalFilterBindGroup.setResource(input.source, 1);\n    this._globalFilterBindGroup.setResource(input.source.style, 2);\n    filter.groups[0] = this._globalFilterBindGroup;\n    renderer.encoder.draw({\n      geometry: quadGeometry,\n      shader: filter,\n      state: filter._state,\n      topology: \"triangle-list\"\n    });\n    if (renderer.type === RendererType.WEBGL) {\n      renderer.renderTarget.finishRenderPass();\n    }\n  }\n  /**\n   * Sets up the filter textures including input texture and back texture if needed.\n   * @param filterData - The filter data to update\n   * @param bounds - The bounds for the texture\n   * @param renderer - The renderer instance\n   * @param previousFilterData - The previous filter data for back texture calculation\n   */\n  _setupFilterTextures(filterData, bounds, renderer, previousFilterData) {\n    filterData.backTexture = Texture.EMPTY;\n    if (filterData.blendRequired) {\n      renderer.renderTarget.finishRenderPass();\n      const renderTarget = renderer.renderTarget.getRenderTarget(filterData.outputRenderSurface);\n      filterData.backTexture = this.getBackTexture(renderTarget, bounds, previousFilterData?.bounds);\n    }\n    filterData.inputTexture = TexturePool.getOptimalTexture(\n      bounds.width,\n      bounds.height,\n      filterData.resolution,\n      filterData.antialias\n    );\n    renderer.renderTarget.bind(filterData.inputTexture, true);\n    renderer.globalUniforms.push({\n      offset: bounds\n    });\n  }\n  /**\n   * Calculates and sets the global frame for the filter.\n   * @param filterData - The filter data to update\n   * @param offsetX - The X offset\n   * @param offsetY - The Y offset\n   * @param globalResolution - The global resolution\n   * @param sourceWidth - The source texture width\n   * @param sourceHeight - The source texture height\n   */\n  _calculateGlobalFrame(filterData, offsetX, offsetY, globalResolution, sourceWidth, sourceHeight) {\n    const globalFrame = filterData.globalFrame;\n    globalFrame.x = offsetX * globalResolution;\n    globalFrame.y = offsetY * globalResolution;\n    globalFrame.width = sourceWidth * globalResolution;\n    globalFrame.height = sourceHeight * globalResolution;\n  }\n  /**\n   * Updates the filter uniforms with the current filter state.\n   * @param input - The input texture\n   * @param output - The output render surface\n   * @param filterData - The current filter data\n   * @param offsetX - The X offset for positioning\n   * @param offsetY - The Y offset for positioning\n   * @param resolution - The current resolution\n   * @param isFinalTarget - Whether this is the final render target\n   * @param clear - Whether to clear the output surface\n   */\n  _updateFilterUniforms(input, output, filterData, offsetX, offsetY, resolution, isFinalTarget, clear) {\n    const uniforms = this._filterGlobalUniforms.uniforms;\n    const outputFrame = uniforms.uOutputFrame;\n    const inputSize = uniforms.uInputSize;\n    const inputPixel = uniforms.uInputPixel;\n    const inputClamp = uniforms.uInputClamp;\n    const globalFrame = uniforms.uGlobalFrame;\n    const outputTexture = uniforms.uOutputTexture;\n    if (isFinalTarget) {\n      outputFrame[0] = filterData.bounds.minX - offsetX;\n      outputFrame[1] = filterData.bounds.minY - offsetY;\n    } else {\n      outputFrame[0] = 0;\n      outputFrame[1] = 0;\n    }\n    outputFrame[2] = input.frame.width;\n    outputFrame[3] = input.frame.height;\n    inputSize[0] = input.source.width;\n    inputSize[1] = input.source.height;\n    inputSize[2] = 1 / inputSize[0];\n    inputSize[3] = 1 / inputSize[1];\n    inputPixel[0] = input.source.pixelWidth;\n    inputPixel[1] = input.source.pixelHeight;\n    inputPixel[2] = 1 / inputPixel[0];\n    inputPixel[3] = 1 / inputPixel[1];\n    inputClamp[0] = 0.5 * inputPixel[2];\n    inputClamp[1] = 0.5 * inputPixel[3];\n    inputClamp[2] = input.frame.width * inputSize[2] - 0.5 * inputPixel[2];\n    inputClamp[3] = input.frame.height * inputSize[3] - 0.5 * inputPixel[3];\n    const rootTexture = this.renderer.renderTarget.rootRenderTarget.colorTexture;\n    globalFrame[0] = offsetX * resolution;\n    globalFrame[1] = offsetY * resolution;\n    globalFrame[2] = rootTexture.source.width * resolution;\n    globalFrame[3] = rootTexture.source.height * resolution;\n    if (output instanceof Texture)\n      output.source.resource = null;\n    const renderTarget = this.renderer.renderTarget.getRenderTarget(output);\n    this.renderer.renderTarget.bind(output, !!clear);\n    if (output instanceof Texture) {\n      outputTexture[0] = output.frame.width;\n      outputTexture[1] = output.frame.height;\n    } else {\n      outputTexture[0] = renderTarget.width;\n      outputTexture[1] = renderTarget.height;\n    }\n    outputTexture[2] = renderTarget.isRoot ? -1 : 1;\n    this._filterGlobalUniforms.update();\n  }\n  /**\n   * Finds the correct resolution by looking back through the filter stack.\n   * @param rootResolution - The fallback root resolution to use\n   * @returns The resolution from the previous filter or root resolution\n   */\n  _findFilterResolution(rootResolution) {\n    let currentIndex = this._filterStackIndex - 1;\n    while (currentIndex > 0 && this._filterStack[currentIndex].skip) {\n      --currentIndex;\n    }\n    return currentIndex > 0 && this._filterStack[currentIndex].inputTexture ? this._filterStack[currentIndex].inputTexture.source._resolution : rootResolution;\n  }\n  /**\n   * Finds the offset from the previous non-skipped filter in the stack.\n   * @returns The offset coordinates from the previous filter\n   */\n  _findPreviousFilterOffset() {\n    let offsetX = 0;\n    let offsetY = 0;\n    let lastIndex = this._filterStackIndex;\n    while (lastIndex > 0) {\n      lastIndex--;\n      const prevFilterData = this._filterStack[lastIndex];\n      if (!prevFilterData.skip) {\n        offsetX = prevFilterData.bounds.minX;\n        offsetY = prevFilterData.bounds.minY;\n        break;\n      }\n    }\n    return { x: offsetX, y: offsetY };\n  }\n  /**\n   * Calculates the filter area bounds based on the instruction type.\n   * @param instruction - The filter instruction\n   * @param bounds - The bounds object to populate\n   */\n  _calculateFilterArea(instruction, bounds) {\n    if (instruction.renderables) {\n      getGlobalRenderableBounds(instruction.renderables, bounds);\n    } else if (instruction.filterEffect.filterArea) {\n      bounds.clear();\n      bounds.addRect(instruction.filterEffect.filterArea);\n      bounds.applyMatrix(instruction.container.worldTransform);\n    } else {\n      instruction.container.getFastGlobalBounds(true, bounds);\n    }\n    if (instruction.container) {\n      const renderGroup = instruction.container.renderGroup || instruction.container.parentRenderGroup;\n      const filterFrameTransform = renderGroup.cacheToLocalTransform;\n      if (filterFrameTransform) {\n        bounds.applyMatrix(filterFrameTransform);\n      }\n    }\n  }\n  _applyFiltersToTexture(filterData, clear) {\n    const inputTexture = filterData.inputTexture;\n    const bounds = filterData.bounds;\n    const filters = filterData.filters;\n    this._globalFilterBindGroup.setResource(inputTexture.source.style, 2);\n    this._globalFilterBindGroup.setResource(filterData.backTexture.source, 3);\n    if (filters.length === 1) {\n      filters[0].apply(this, inputTexture, filterData.outputRenderSurface, clear);\n    } else {\n      let flip = filterData.inputTexture;\n      const tempTexture = TexturePool.getOptimalTexture(\n        bounds.width,\n        bounds.height,\n        flip.source._resolution,\n        false\n      );\n      let flop = tempTexture;\n      let i = 0;\n      for (i = 0; i < filters.length - 1; ++i) {\n        const filter = filters[i];\n        filter.apply(this, flip, flop, true);\n        const t = flip;\n        flip = flop;\n        flop = t;\n      }\n      filters[i].apply(this, flip, filterData.outputRenderSurface, clear);\n      TexturePool.returnTexture(tempTexture);\n    }\n  }\n  _calculateFilterBounds(filterData, viewPort, rootAntialias, rootResolution, paddingMultiplier) {\n    const renderer = this.renderer;\n    const bounds = filterData.bounds;\n    const filters = filterData.filters;\n    let resolution = Infinity;\n    let padding = 0;\n    let antialias = true;\n    let blendRequired = false;\n    let enabled = false;\n    let clipToViewport = true;\n    for (let i = 0; i < filters.length; i++) {\n      const filter = filters[i];\n      resolution = Math.min(resolution, filter.resolution === \"inherit\" ? rootResolution : filter.resolution);\n      padding += filter.padding;\n      if (filter.antialias === \"off\") {\n        antialias = false;\n      } else if (filter.antialias === \"inherit\") {\n        antialias && (antialias = rootAntialias);\n      }\n      if (!filter.clipToViewport) {\n        clipToViewport = false;\n      }\n      const isCompatible = !!(filter.compatibleRenderers & renderer.type);\n      if (!isCompatible) {\n        enabled = false;\n        break;\n      }\n      if (filter.blendRequired && !(renderer.backBuffer?.useBackBuffer ?? true)) {\n        warn(\"Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options.\");\n        enabled = false;\n        break;\n      }\n      enabled = filter.enabled || enabled;\n      blendRequired || (blendRequired = filter.blendRequired);\n    }\n    if (!enabled) {\n      filterData.skip = true;\n      return;\n    }\n    if (clipToViewport) {\n      bounds.fitBounds(0, viewPort.width / rootResolution, 0, viewPort.height / rootResolution);\n    }\n    bounds.scale(resolution).ceil().scale(1 / resolution).pad((padding | 0) * paddingMultiplier);\n    if (!bounds.isPositive) {\n      filterData.skip = true;\n      return;\n    }\n    filterData.antialias = antialias;\n    filterData.resolution = resolution;\n    filterData.blendRequired = blendRequired;\n  }\n  _popFilterData() {\n    this._filterStackIndex--;\n    return this._filterStack[this._filterStackIndex];\n  }\n  _getPreviousFilterData() {\n    let previousFilterData;\n    let index = this._filterStackIndex - 1;\n    while (index > 1) {\n      index--;\n      previousFilterData = this._filterStack[index];\n      if (!previousFilterData.skip) {\n        break;\n      }\n    }\n    return previousFilterData;\n  }\n  _pushFilterData() {\n    let filterData = this._filterStack[this._filterStackIndex];\n    if (!filterData) {\n      filterData = this._filterStack[this._filterStackIndex] = new FilterData();\n    }\n    this._filterStackIndex++;\n    return filterData;\n  }\n}\n/** @ignore */\nFilterSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"filter\"\n};\n\nexport { FilterSystem };\n//# sourceMappingURL=FilterSystem.mjs.map\n","\"use strict\";\nfunction getGlobalRenderableBounds(renderables, bounds) {\n  bounds.clear();\n  const tempMatrix = bounds.matrix;\n  for (let i = 0; i < renderables.length; i++) {\n    const renderable = renderables[i];\n    if (renderable.globalDisplayStatus < 7) {\n      continue;\n    }\n    bounds.matrix = renderable.worldTransform;\n    bounds.addBounds(renderable.bounds);\n  }\n  bounds.matrix = tempMatrix;\n  return bounds;\n}\n\nexport { getGlobalRenderableBounds };\n//# sourceMappingURL=getRenderableBounds.mjs.map\n","import { extensions } from '../extensions/Extensions.mjs';\nimport { FilterPipe } from './FilterPipe.mjs';\nimport { FilterSystem } from './FilterSystem.mjs';\n\n\"use strict\";\nextensions.add(FilterSystem);\nextensions.add(FilterPipe);\n//# sourceMappingURL=init.mjs.map\n","import { Buffer } from '../../../rendering/renderers/shared/buffer/Buffer.mjs';\nimport { BufferUsage } from '../../../rendering/renderers/shared/buffer/const.mjs';\nimport { Geometry } from '../../../rendering/renderers/shared/geometry/Geometry.mjs';\nimport { deprecation, v8_0_0 } from '../../../utils/logging/deprecation.mjs';\n\n\"use strict\";\nconst _MeshGeometry = class _MeshGeometry extends Geometry {\n  constructor(...args) {\n    let options = args[0] ?? {};\n    if (options instanceof Float32Array) {\n      deprecation(v8_0_0, \"use new MeshGeometry({ positions, uvs, indices }) instead\");\n      options = {\n        positions: options,\n        uvs: args[1],\n        indices: args[2]\n      };\n    }\n    options = { ..._MeshGeometry.defaultOptions, ...options };\n    const positions = options.positions || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);\n    let uvs = options.uvs;\n    if (!uvs) {\n      if (options.positions) {\n        uvs = new Float32Array(positions.length);\n      } else {\n        uvs = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);\n      }\n    }\n    const indices = options.indices || new Uint32Array([0, 1, 2, 0, 2, 3]);\n    const shrinkToFit = options.shrinkBuffersToFit;\n    const positionBuffer = new Buffer({\n      data: positions,\n      label: \"attribute-mesh-positions\",\n      shrinkToFit,\n      usage: BufferUsage.VERTEX | BufferUsage.COPY_DST\n    });\n    const uvBuffer = new Buffer({\n      data: uvs,\n      label: \"attribute-mesh-uvs\",\n      shrinkToFit,\n      usage: BufferUsage.VERTEX | BufferUsage.COPY_DST\n    });\n    const indexBuffer = new Buffer({\n      data: indices,\n      label: \"index-mesh-buffer\",\n      shrinkToFit,\n      usage: BufferUsage.INDEX | BufferUsage.COPY_DST\n    });\n    super({\n      attributes: {\n        aPosition: {\n          buffer: positionBuffer,\n          format: \"float32x2\",\n          stride: 2 * 4,\n          offset: 0\n        },\n        aUV: {\n          buffer: uvBuffer,\n          format: \"float32x2\",\n          stride: 2 * 4,\n          offset: 0\n        }\n      },\n      indexBuffer,\n      topology: options.topology\n    });\n    this.batchMode = \"auto\";\n  }\n  /** The positions of the mesh. */\n  get positions() {\n    return this.attributes.aPosition.buffer.data;\n  }\n  /**\n   * Set the positions of the mesh.\n   * When setting the positions, its important that the uvs array is at least as long as the positions array.\n   * otherwise the geometry will not be valid.\n   * @param {Float32Array} value - The positions of the mesh.\n   */\n  set positions(value) {\n    this.attributes.aPosition.buffer.data = value;\n  }\n  /** The UVs of the mesh. */\n  get uvs() {\n    return this.attributes.aUV.buffer.data;\n  }\n  /**\n   * Set the UVs of the mesh.\n   * Its important that the uvs array you set is at least as long as the positions array.\n   * otherwise the geometry will not be valid.\n   * @param {Float32Array} value - The UVs of the mesh.\n   */\n  set uvs(value) {\n    this.attributes.aUV.buffer.data = value;\n  }\n  /** The indices of the mesh. */\n  get indices() {\n    return this.indexBuffer.data;\n  }\n  set indices(value) {\n    this.indexBuffer.data = value;\n  }\n};\n_MeshGeometry.defaultOptions = {\n  topology: \"triangle-list\",\n  shrinkBuffersToFit: false\n};\nlet MeshGeometry = _MeshGeometry;\n\nexport { MeshGeometry };\n//# sourceMappingURL=MeshGeometry.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { BindGroup } from '../../../rendering/renderers/gpu/shader/BindGroup.mjs';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup.mjs';\nimport { getAdjustedBlendModeBlend } from '../../../rendering/renderers/shared/state/getAdjustedBlendModeBlend.mjs';\nimport { color32BitToUniform } from '../../graphics/gpu/colorToUniform.mjs';\nimport { BatchableMesh } from './BatchableMesh.mjs';\n\n\"use strict\";\nclass MeshGpuData {\n  destroy() {\n  }\n}\nclass MeshPipe {\n  constructor(renderer, adaptor) {\n    this.localUniforms = new UniformGroup({\n      uTransformMatrix: { value: new Matrix(), type: \"mat3x3<f32>\" },\n      uColor: { value: new Float32Array([1, 1, 1, 1]), type: \"vec4<f32>\" },\n      uRound: { value: 0, type: \"f32\" }\n    });\n    this.localUniformsBindGroup = new BindGroup({\n      0: this.localUniforms\n    });\n    this.renderer = renderer;\n    this._adaptor = adaptor;\n    this._adaptor.init();\n  }\n  validateRenderable(mesh) {\n    const meshData = this._getMeshData(mesh);\n    const wasBatched = meshData.batched;\n    const isBatched = mesh.batched;\n    meshData.batched = isBatched;\n    if (wasBatched !== isBatched) {\n      return true;\n    } else if (isBatched) {\n      const geometry = mesh._geometry;\n      if (geometry.indices.length !== meshData.indexSize || geometry.positions.length !== meshData.vertexSize) {\n        meshData.indexSize = geometry.indices.length;\n        meshData.vertexSize = geometry.positions.length;\n        return true;\n      }\n      const batchableMesh = this._getBatchableMesh(mesh);\n      if (batchableMesh.texture.uid !== mesh._texture.uid) {\n        batchableMesh._textureMatrixUpdateId = -1;\n      }\n      return !batchableMesh._batcher.checkAndUpdateTexture(\n        batchableMesh,\n        mesh._texture\n      );\n    }\n    return false;\n  }\n  addRenderable(mesh, instructionSet) {\n    const batcher = this.renderer.renderPipes.batch;\n    const meshData = this._getMeshData(mesh);\n    if (mesh.didViewUpdate) {\n      meshData.indexSize = mesh._geometry.indices?.length;\n      meshData.vertexSize = mesh._geometry.positions?.length;\n    }\n    if (meshData.batched) {\n      const gpuBatchableMesh = this._getBatchableMesh(mesh);\n      gpuBatchableMesh.setTexture(mesh._texture);\n      gpuBatchableMesh.geometry = mesh._geometry;\n      batcher.addToBatch(gpuBatchableMesh, instructionSet);\n    } else {\n      batcher.break(instructionSet);\n      instructionSet.add(mesh);\n    }\n  }\n  updateRenderable(mesh) {\n    if (mesh.batched) {\n      const gpuBatchableMesh = this._getBatchableMesh(mesh);\n      gpuBatchableMesh.setTexture(mesh._texture);\n      gpuBatchableMesh.geometry = mesh._geometry;\n      gpuBatchableMesh._batcher.updateElement(gpuBatchableMesh);\n    }\n  }\n  execute(mesh) {\n    if (!mesh.isRenderable)\n      return;\n    mesh.state.blendMode = getAdjustedBlendModeBlend(mesh.groupBlendMode, mesh.texture._source);\n    const localUniforms = this.localUniforms;\n    localUniforms.uniforms.uTransformMatrix = mesh.groupTransform;\n    localUniforms.uniforms.uRound = this.renderer._roundPixels | mesh._roundPixels;\n    localUniforms.update();\n    color32BitToUniform(\n      mesh.groupColorAlpha,\n      localUniforms.uniforms.uColor,\n      0\n    );\n    this._adaptor.execute(this, mesh);\n  }\n  _getMeshData(mesh) {\n    var _a, _b;\n    (_a = mesh._gpuData)[_b = this.renderer.uid] || (_a[_b] = new MeshGpuData());\n    return mesh._gpuData[this.renderer.uid].meshData || this._initMeshData(mesh);\n  }\n  _initMeshData(mesh) {\n    mesh._gpuData[this.renderer.uid].meshData = {\n      batched: mesh.batched,\n      indexSize: 0,\n      vertexSize: 0\n    };\n    return mesh._gpuData[this.renderer.uid].meshData;\n  }\n  _getBatchableMesh(mesh) {\n    var _a, _b;\n    (_a = mesh._gpuData)[_b = this.renderer.uid] || (_a[_b] = new MeshGpuData());\n    return mesh._gpuData[this.renderer.uid].batchableMesh || this._initBatchableMesh(mesh);\n  }\n  _initBatchableMesh(mesh) {\n    const gpuMesh = new BatchableMesh();\n    gpuMesh.renderable = mesh;\n    gpuMesh.setTexture(mesh._texture);\n    gpuMesh.transform = mesh.groupTransform;\n    gpuMesh.roundPixels = this.renderer._roundPixels | mesh._roundPixels;\n    mesh._gpuData[this.renderer.uid].batchableMesh = gpuMesh;\n    return gpuMesh;\n  }\n  destroy() {\n    this.localUniforms = null;\n    this.localUniformsBindGroup = null;\n    this._adaptor.destroy();\n    this._adaptor = null;\n    this.renderer = null;\n  }\n}\n/** @ignore */\nMeshPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"mesh\"\n};\n\nexport { MeshGpuData, MeshPipe };\n//# sourceMappingURL=MeshPipe.mjs.map\n","import { extensions } from '../../extensions/Extensions.mjs';\nimport { MeshPipe } from './shared/MeshPipe.mjs';\n\n\"use strict\";\nextensions.add(MeshPipe);\n//# sourceMappingURL=init.mjs.map\n","\"use strict\";\nconst localUniformMSDFBit = {\n  name: \"local-uniform-msdf-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32,\n                uRound:f32,\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `\n    ),\n    end: (\n      /* wgsl */\n      `\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    )\n  },\n  fragment: {\n    header: (\n      /* wgsl */\n      `\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n         `\n    ),\n    main: (\n      /* wgsl */\n      `\n            outColor = vec4<f32>(calculateMSDFAlpha(outColor, localUniforms.uColor, localUniforms.uDistance));\n        `\n    )\n  }\n};\nconst localUniformMSDFBitGl = {\n  name: \"local-uniform-msdf-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            vColor *= uColor;\n            modelMatrix *= uTransformMatrix;\n        `\n    ),\n    end: (\n      /* glsl */\n      `\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    )\n  },\n  fragment: {\n    header: (\n      /* glsl */\n      `\n            uniform float uDistance;\n         `\n    ),\n    main: (\n      /* glsl */\n      `\n            outColor = vec4(calculateMSDFAlpha(outColor, vColor, uDistance));\n        `\n    )\n  }\n};\n\nexport { localUniformMSDFBit, localUniformMSDFBitGl };\n//# sourceMappingURL=localUniformMSDFBit.mjs.map\n","\"use strict\";\nconst mSDFBit = {\n  name: \"msdf-bit\",\n  fragment: {\n    header: (\n      /* wgsl */\n      `\n            fn calculateMSDFAlpha(msdfColor:vec4<f32>, shapeColor:vec4<f32>, distance:f32) -> f32 {\n\n                // MSDF\n                var median = msdfColor.r + msdfColor.g + msdfColor.b -\n                    min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                    max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n\n                // SDF\n                median = min(median, msdfColor.a);\n\n                var screenPxDistance = distance * (median - 0.5);\n                var alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n                if (median < 0.01) {\n                    alpha = 0.0;\n                } else if (median > 0.99) {\n                    alpha = 1.0;\n                }\n\n                // Gamma correction for coverage-like alpha\n                var luma: f32 = dot(shapeColor.rgb, vec3<f32>(0.299, 0.587, 0.114));\n                var gamma: f32 = mix(1.0, 1.0 / 2.2, luma);\n                var coverage: f32 = pow(shapeColor.a * alpha, gamma);\n\n                return coverage;\n\n            }\n        `\n    )\n  }\n};\nconst mSDFBitGl = {\n  name: \"msdf-bit\",\n  fragment: {\n    header: (\n      /* glsl */\n      `\n            float calculateMSDFAlpha(vec4 msdfColor, vec4 shapeColor, float distance) {\n\n                // MSDF\n                float median = msdfColor.r + msdfColor.g + msdfColor.b -\n                                min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                                max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n\n                // SDF\n                median = min(median, msdfColor.a);\n\n                float screenPxDistance = distance * (median - 0.5);\n                float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n\n                if (median < 0.01) {\n                    alpha = 0.0;\n                } else if (median > 0.99) {\n                    alpha = 1.0;\n                }\n\n                // Gamma correction for coverage-like alpha\n                float luma = dot(shapeColor.rgb, vec3(0.299, 0.587, 0.114));\n                float gamma = mix(1.0, 1.0 / 2.2, luma);\n                float coverage = pow(shapeColor.a * alpha, gamma);\n\n                return coverage;\n            }\n        `\n    )\n  }\n};\n\nexport { mSDFBit, mSDFBitGl };\n//# sourceMappingURL=mSDFBit.mjs.map\n","import { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { compileHighShaderGpuProgram, compileHighShaderGlProgram } from '../../../rendering/high-shader/compileHighShaderToProgram.mjs';\nimport { colorBit, colorBitGl } from '../../../rendering/high-shader/shader-bits/colorBit.mjs';\nimport { generateTextureBatchBit, generateTextureBatchBitGl } from '../../../rendering/high-shader/shader-bits/generateTextureBatchBit.mjs';\nimport { roundPixelsBit, roundPixelsBitGl } from '../../../rendering/high-shader/shader-bits/roundPixelsBit.mjs';\nimport { getBatchSamplersUniformGroup } from '../../../rendering/renderers/gl/shader/getBatchSamplersUniformGroup.mjs';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader.mjs';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup.mjs';\nimport { localUniformMSDFBit, localUniformMSDFBitGl } from './shader-bits/localUniformMSDFBit.mjs';\nimport { mSDFBit, mSDFBitGl } from './shader-bits/mSDFBit.mjs';\n\n\"use strict\";\nlet gpuProgram;\nlet glProgram;\nclass SdfShader extends Shader {\n  constructor(maxTextures) {\n    const uniforms = new UniformGroup({\n      uColor: { value: new Float32Array([1, 1, 1, 1]), type: \"vec4<f32>\" },\n      uTransformMatrix: { value: new Matrix(), type: \"mat3x3<f32>\" },\n      uDistance: { value: 4, type: \"f32\" },\n      uRound: { value: 0, type: \"f32\" }\n    });\n    gpuProgram ?? (gpuProgram = compileHighShaderGpuProgram({\n      name: \"sdf-shader\",\n      bits: [\n        colorBit,\n        generateTextureBatchBit(maxTextures),\n        localUniformMSDFBit,\n        mSDFBit,\n        roundPixelsBit\n      ]\n    }));\n    glProgram ?? (glProgram = compileHighShaderGlProgram({\n      name: \"sdf-shader\",\n      bits: [\n        colorBitGl,\n        generateTextureBatchBitGl(maxTextures),\n        localUniformMSDFBitGl,\n        mSDFBitGl,\n        roundPixelsBitGl\n      ]\n    }));\n    super({\n      glProgram,\n      gpuProgram,\n      resources: {\n        localUniforms: uniforms,\n        batchSamplers: getBatchSamplersUniformGroup(maxTextures)\n      }\n    });\n  }\n}\n\nexport { SdfShader };\n//# sourceMappingURL=SdfShader.mjs.map\n","import { Cache } from '../../assets/cache/Cache.mjs';\nimport { ExtensionType } from '../../extensions/Extensions.mjs';\nimport { Graphics } from '../graphics/shared/Graphics.mjs';\nimport { CanvasTextMetrics } from '../text/canvas/CanvasTextMetrics.mjs';\nimport { SdfShader } from '../text/sdfShader/SdfShader.mjs';\nimport { BitmapFontManager } from './BitmapFontManager.mjs';\nimport { getBitmapTextLayout } from './utils/getBitmapTextLayout.mjs';\n\n\"use strict\";\nclass BitmapTextGraphics extends Graphics {\n  destroy() {\n    if (this.context.customShader) {\n      this.context.customShader.destroy();\n    }\n    super.destroy();\n  }\n}\nclass BitmapTextPipe {\n  constructor(renderer) {\n    this._renderer = renderer;\n    this._renderer.renderableGC.addManagedHash(this, \"_gpuBitmapText\");\n  }\n  validateRenderable(bitmapText) {\n    const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n    return this._renderer.renderPipes.graphics.validateRenderable(graphicsRenderable);\n  }\n  addRenderable(bitmapText, instructionSet) {\n    const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n    syncWithProxy(bitmapText, graphicsRenderable);\n    if (bitmapText._didTextUpdate) {\n      bitmapText._didTextUpdate = false;\n      this._updateContext(bitmapText, graphicsRenderable);\n    }\n    this._renderer.renderPipes.graphics.addRenderable(graphicsRenderable, instructionSet);\n    if (graphicsRenderable.context.customShader) {\n      this._updateDistanceField(bitmapText);\n    }\n  }\n  updateRenderable(bitmapText) {\n    const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n    syncWithProxy(bitmapText, graphicsRenderable);\n    this._renderer.renderPipes.graphics.updateRenderable(graphicsRenderable);\n    if (graphicsRenderable.context.customShader) {\n      this._updateDistanceField(bitmapText);\n    }\n  }\n  _updateContext(bitmapText, proxyGraphics) {\n    const { context } = proxyGraphics;\n    const bitmapFont = BitmapFontManager.getFont(bitmapText.text, bitmapText._style);\n    context.clear();\n    if (bitmapFont.distanceField.type !== \"none\") {\n      if (!context.customShader) {\n        context.customShader = new SdfShader(this._renderer.limits.maxBatchableTextures);\n      }\n    }\n    const chars = CanvasTextMetrics.graphemeSegmenter(bitmapText.text);\n    const style = bitmapText._style;\n    let currentY = bitmapFont.baseLineOffset;\n    const bitmapTextLayout = getBitmapTextLayout(chars, style, bitmapFont, true);\n    const padding = style.padding;\n    const scale = bitmapTextLayout.scale;\n    let tx = bitmapTextLayout.width;\n    let ty = bitmapTextLayout.height + bitmapTextLayout.offsetY;\n    if (style._stroke) {\n      tx += style._stroke.width / scale;\n      ty += style._stroke.width / scale;\n    }\n    context.translate(-bitmapText._anchor._x * tx - padding, -bitmapText._anchor._y * ty - padding).scale(scale, scale);\n    const tint = bitmapFont.applyFillAsTint ? style._fill.color : 16777215;\n    let fontSize = bitmapFont.fontMetrics.fontSize;\n    let lineHeight = bitmapFont.lineHeight;\n    if (style.lineHeight) {\n      fontSize = style.fontSize / scale;\n      lineHeight = style.lineHeight / scale;\n    }\n    let linePositionYShift = (lineHeight - fontSize) / 2;\n    if (linePositionYShift - bitmapFont.baseLineOffset < 0) {\n      linePositionYShift = 0;\n    }\n    for (let i = 0; i < bitmapTextLayout.lines.length; i++) {\n      const line = bitmapTextLayout.lines[i];\n      for (let j = 0; j < line.charPositions.length; j++) {\n        const char = line.chars[j];\n        const charData = bitmapFont.chars[char];\n        if (charData?.texture) {\n          const texture = charData.texture;\n          context.texture(\n            texture,\n            tint ? tint : \"black\",\n            Math.round(line.charPositions[j] + charData.xOffset),\n            Math.round(currentY + charData.yOffset + linePositionYShift),\n            texture.orig.width,\n            texture.orig.height\n          );\n        }\n      }\n      currentY += lineHeight;\n    }\n  }\n  _getGpuBitmapText(bitmapText) {\n    return bitmapText._gpuData[this._renderer.uid] || this.initGpuText(bitmapText);\n  }\n  initGpuText(bitmapText) {\n    const proxyRenderable = new BitmapTextGraphics();\n    bitmapText._gpuData[this._renderer.uid] = proxyRenderable;\n    this._updateContext(bitmapText, proxyRenderable);\n    return proxyRenderable;\n  }\n  _updateDistanceField(bitmapText) {\n    const context = this._getGpuBitmapText(bitmapText).context;\n    const fontFamily = bitmapText._style.fontFamily;\n    const dynamicFont = Cache.get(`${fontFamily}-bitmap`);\n    const { a, b, c, d } = bitmapText.groupTransform;\n    const dx = Math.sqrt(a * a + b * b);\n    const dy = Math.sqrt(c * c + d * d);\n    const worldScale = (Math.abs(dx) + Math.abs(dy)) / 2;\n    const fontScale = dynamicFont.baseRenderedFontSize / bitmapText._style.fontSize;\n    const distance = worldScale * dynamicFont.distanceField.range * (1 / fontScale);\n    context.customShader.resources.localUniforms.uniforms.uDistance = distance;\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\n/** @ignore */\nBitmapTextPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"bitmapText\"\n};\nfunction syncWithProxy(container, proxy) {\n  proxy.groupTransform = container.groupTransform;\n  proxy.groupColorAlpha = container.groupColorAlpha;\n  proxy.groupColor = container.groupColor;\n  proxy.groupBlendMode = container.groupBlendMode;\n  proxy.globalDisplayStatus = container.globalDisplayStatus;\n  proxy.groupTransform = container.groupTransform;\n  proxy.localDisplayStatus = container.localDisplayStatus;\n  proxy.groupAlpha = container.groupAlpha;\n  proxy._roundPixels = container._roundPixels;\n}\n\nexport { BitmapTextGraphics, BitmapTextPipe };\n//# sourceMappingURL=BitmapTextPipe.mjs.map\n","import { extensions } from '../../extensions/Extensions.mjs';\nimport { BitmapTextPipe } from './BitmapTextPipe.mjs';\n\n\"use strict\";\nextensions.add(BitmapTextPipe);\n//# sourceMappingURL=init.mjs.map\n","import { deprecation, v8_0_0 } from '../../utils/logging/deprecation.mjs';\nimport { MeshGeometry } from '../mesh/shared/MeshGeometry.mjs';\n\n\"use strict\";\nconst _PlaneGeometry = class _PlaneGeometry extends MeshGeometry {\n  constructor(...args) {\n    super({});\n    let options = args[0] ?? {};\n    if (typeof options === \"number\") {\n      deprecation(v8_0_0, \"PlaneGeometry constructor changed please use { width, height, verticesX, verticesY } instead\");\n      options = {\n        width: options,\n        height: args[1],\n        verticesX: args[2],\n        verticesY: args[3]\n      };\n    }\n    this.build(options);\n  }\n  /**\n   * Refreshes plane coordinates\n   * @param options - Options to be applied to plane geometry\n   */\n  build(options) {\n    options = { ..._PlaneGeometry.defaultOptions, ...options };\n    this.verticesX = this.verticesX ?? options.verticesX;\n    this.verticesY = this.verticesY ?? options.verticesY;\n    this.width = this.width ?? options.width;\n    this.height = this.height ?? options.height;\n    const total = this.verticesX * this.verticesY;\n    const verts = [];\n    const uvs = [];\n    const indices = [];\n    const verticesX = this.verticesX - 1;\n    const verticesY = this.verticesY - 1;\n    const sizeX = this.width / verticesX;\n    const sizeY = this.height / verticesY;\n    for (let i = 0; i < total; i++) {\n      const x = i % this.verticesX;\n      const y = i / this.verticesX | 0;\n      verts.push(x * sizeX, y * sizeY);\n      uvs.push(x / verticesX, y / verticesY);\n    }\n    const totalSub = verticesX * verticesY;\n    for (let i = 0; i < totalSub; i++) {\n      const xpos = i % verticesX;\n      const ypos = i / verticesX | 0;\n      const value = ypos * this.verticesX + xpos;\n      const value2 = ypos * this.verticesX + xpos + 1;\n      const value3 = (ypos + 1) * this.verticesX + xpos;\n      const value4 = (ypos + 1) * this.verticesX + xpos + 1;\n      indices.push(\n        value,\n        value2,\n        value3,\n        value2,\n        value4,\n        value3\n      );\n    }\n    this.buffers[0].data = new Float32Array(verts);\n    this.buffers[1].data = new Float32Array(uvs);\n    this.indexBuffer.data = new Uint32Array(indices);\n    this.buffers[0].update();\n    this.buffers[1].update();\n    this.indexBuffer.update();\n  }\n};\n_PlaneGeometry.defaultOptions = {\n  width: 100,\n  height: 100,\n  verticesX: 10,\n  verticesY: 10\n};\nlet PlaneGeometry = _PlaneGeometry;\n\nexport { PlaneGeometry };\n//# sourceMappingURL=PlaneGeometry.mjs.map\n","import { PlaneGeometry } from '../mesh-plane/PlaneGeometry.mjs';\n\n\"use strict\";\nconst _NineSliceGeometry = class _NineSliceGeometry extends PlaneGeometry {\n  constructor(options = {}) {\n    options = { ..._NineSliceGeometry.defaultOptions, ...options };\n    super({\n      width: options.width,\n      height: options.height,\n      verticesX: 4,\n      verticesY: 4\n    });\n    this.update(options);\n  }\n  /**\n   * Updates the NineSliceGeometry with the options.\n   * @param options - The options of the NineSliceGeometry.\n   */\n  update(options) {\n    this.width = options.width ?? this.width;\n    this.height = options.height ?? this.height;\n    this._originalWidth = options.originalWidth ?? this._originalWidth;\n    this._originalHeight = options.originalHeight ?? this._originalHeight;\n    this._leftWidth = options.leftWidth ?? this._leftWidth;\n    this._rightWidth = options.rightWidth ?? this._rightWidth;\n    this._topHeight = options.topHeight ?? this._topHeight;\n    this._bottomHeight = options.bottomHeight ?? this._bottomHeight;\n    this._anchorX = options.anchor?.x;\n    this._anchorY = options.anchor?.y;\n    this.updateUvs();\n    this.updatePositions();\n  }\n  /** Updates the positions of the vertices. */\n  updatePositions() {\n    const p = this.positions;\n    const {\n      width,\n      height,\n      _leftWidth,\n      _rightWidth,\n      _topHeight,\n      _bottomHeight,\n      _anchorX,\n      _anchorY\n    } = this;\n    const w = _leftWidth + _rightWidth;\n    const scaleW = width > w ? 1 : width / w;\n    const h = _topHeight + _bottomHeight;\n    const scaleH = height > h ? 1 : height / h;\n    const scale = Math.min(scaleW, scaleH);\n    const anchorOffsetX = _anchorX * width;\n    const anchorOffsetY = _anchorY * height;\n    p[0] = p[8] = p[16] = p[24] = -anchorOffsetX;\n    p[2] = p[10] = p[18] = p[26] = _leftWidth * scale - anchorOffsetX;\n    p[4] = p[12] = p[20] = p[28] = width - _rightWidth * scale - anchorOffsetX;\n    p[6] = p[14] = p[22] = p[30] = width - anchorOffsetX;\n    p[1] = p[3] = p[5] = p[7] = -anchorOffsetY;\n    p[9] = p[11] = p[13] = p[15] = _topHeight * scale - anchorOffsetY;\n    p[17] = p[19] = p[21] = p[23] = height - _bottomHeight * scale - anchorOffsetY;\n    p[25] = p[27] = p[29] = p[31] = height - anchorOffsetY;\n    this.getBuffer(\"aPosition\").update();\n  }\n  /** Updates the UVs of the vertices. */\n  updateUvs() {\n    const uvs = this.uvs;\n    uvs[0] = uvs[8] = uvs[16] = uvs[24] = 0;\n    uvs[1] = uvs[3] = uvs[5] = uvs[7] = 0;\n    uvs[6] = uvs[14] = uvs[22] = uvs[30] = 1;\n    uvs[25] = uvs[27] = uvs[29] = uvs[31] = 1;\n    const _uvw = 1 / this._originalWidth;\n    const _uvh = 1 / this._originalHeight;\n    uvs[2] = uvs[10] = uvs[18] = uvs[26] = _uvw * this._leftWidth;\n    uvs[9] = uvs[11] = uvs[13] = uvs[15] = _uvh * this._topHeight;\n    uvs[4] = uvs[12] = uvs[20] = uvs[28] = 1 - _uvw * this._rightWidth;\n    uvs[17] = uvs[19] = uvs[21] = uvs[23] = 1 - _uvh * this._bottomHeight;\n    this.getBuffer(\"aUV\").update();\n  }\n};\n/** The default options for the NineSliceGeometry. */\n_NineSliceGeometry.defaultOptions = {\n  /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n  width: 100,\n  /** The height of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n  height: 100,\n  /** The width of the left column. */\n  leftWidth: 10,\n  /** The height of the top row. */\n  topHeight: 10,\n  /** The width of the right column. */\n  rightWidth: 10,\n  /** The height of the bottom row. */\n  bottomHeight: 10,\n  /** The original width of the texture */\n  originalWidth: 100,\n  /** The original height of the texture */\n  originalHeight: 100\n};\nlet NineSliceGeometry = _NineSliceGeometry;\n\nexport { NineSliceGeometry };\n//# sourceMappingURL=NineSliceGeometry.mjs.map\n","import { ExtensionType } from '../../extensions/Extensions.mjs';\nimport { BatchableMesh } from '../mesh/shared/BatchableMesh.mjs';\nimport { NineSliceGeometry } from './NineSliceGeometry.mjs';\n\n\"use strict\";\nclass NineSliceSpriteGpuData extends BatchableMesh {\n  constructor() {\n    super();\n    this.geometry = new NineSliceGeometry();\n  }\n  destroy() {\n    this.geometry.destroy();\n  }\n}\nclass NineSliceSpritePipe {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  addRenderable(sprite, instructionSet) {\n    const gpuSprite = this._getGpuSprite(sprite);\n    if (sprite.didViewUpdate)\n      this._updateBatchableSprite(sprite, gpuSprite);\n    this._renderer.renderPipes.batch.addToBatch(gpuSprite, instructionSet);\n  }\n  updateRenderable(sprite) {\n    const gpuSprite = this._getGpuSprite(sprite);\n    if (sprite.didViewUpdate)\n      this._updateBatchableSprite(sprite, gpuSprite);\n    gpuSprite._batcher.updateElement(gpuSprite);\n  }\n  validateRenderable(sprite) {\n    const gpuSprite = this._getGpuSprite(sprite);\n    return !gpuSprite._batcher.checkAndUpdateTexture(\n      gpuSprite,\n      sprite._texture\n    );\n  }\n  _updateBatchableSprite(sprite, batchableSprite) {\n    batchableSprite.geometry.update(sprite);\n    batchableSprite.setTexture(sprite._texture);\n  }\n  _getGpuSprite(sprite) {\n    return sprite._gpuData[this._renderer.uid] || this._initGPUSprite(sprite);\n  }\n  _initGPUSprite(sprite) {\n    const gpuData = sprite._gpuData[this._renderer.uid] = new NineSliceSpriteGpuData();\n    const batchableMesh = gpuData;\n    batchableMesh.renderable = sprite;\n    batchableMesh.transform = sprite.groupTransform;\n    batchableMesh.texture = sprite._texture;\n    batchableMesh.roundPixels = this._renderer._roundPixels | sprite._roundPixels;\n    if (!sprite.didViewUpdate) {\n      this._updateBatchableSprite(sprite, batchableMesh);\n    }\n    return gpuData;\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\n/** @ignore */\nNineSliceSpritePipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"nineSliceSprite\"\n};\n\nexport { NineSliceSpriteGpuData, NineSliceSpritePipe };\n//# sourceMappingURL=NineSliceSpritePipe.mjs.map\n","import { extensions } from '../../extensions/Extensions.mjs';\nimport { NineSliceSpritePipe } from './NineSliceSpritePipe.mjs';\n\n\"use strict\";\nextensions.add(NineSliceSpritePipe);\n//# sourceMappingURL=init.mjs.map\n","\"use strict\";\nconst blendModeIds = {\n  normal: 0,\n  add: 1,\n  multiply: 2,\n  screen: 3,\n  overlay: 4,\n  erase: 5,\n  \"normal-npm\": 6,\n  \"add-npm\": 7,\n  \"screen-npm\": 8,\n  min: 9,\n  max: 10\n};\nconst BLEND = 0;\nconst OFFSET = 1;\nconst CULLING = 2;\nconst DEPTH_TEST = 3;\nconst WINDING = 4;\nconst DEPTH_MASK = 5;\nconst _State = class _State {\n  constructor() {\n    this.data = 0;\n    this.blendMode = \"normal\";\n    this.polygonOffset = 0;\n    this.blend = true;\n    this.depthMask = true;\n  }\n  /**\n   * Activates blending of the computed fragment color values.\n   * @default true\n   */\n  get blend() {\n    return !!(this.data & 1 << BLEND);\n  }\n  set blend(value) {\n    if (!!(this.data & 1 << BLEND) !== value) {\n      this.data ^= 1 << BLEND;\n    }\n  }\n  /**\n   * Activates adding an offset to depth values of polygon's fragments\n   * @default false\n   */\n  get offsets() {\n    return !!(this.data & 1 << OFFSET);\n  }\n  set offsets(value) {\n    if (!!(this.data & 1 << OFFSET) !== value) {\n      this.data ^= 1 << OFFSET;\n    }\n  }\n  /** The culling settings for this state none - No culling back - Back face culling front - Front face culling */\n  set cullMode(value) {\n    if (value === \"none\") {\n      this.culling = false;\n      return;\n    }\n    this.culling = true;\n    this.clockwiseFrontFace = value === \"front\";\n  }\n  get cullMode() {\n    if (!this.culling) {\n      return \"none\";\n    }\n    return this.clockwiseFrontFace ? \"front\" : \"back\";\n  }\n  /**\n   * Activates culling of polygons.\n   * @default false\n   */\n  get culling() {\n    return !!(this.data & 1 << CULLING);\n  }\n  set culling(value) {\n    if (!!(this.data & 1 << CULLING) !== value) {\n      this.data ^= 1 << CULLING;\n    }\n  }\n  /**\n   * Activates depth comparisons and updates to the depth buffer.\n   * @default false\n   */\n  get depthTest() {\n    return !!(this.data & 1 << DEPTH_TEST);\n  }\n  set depthTest(value) {\n    if (!!(this.data & 1 << DEPTH_TEST) !== value) {\n      this.data ^= 1 << DEPTH_TEST;\n    }\n  }\n  /**\n   * Enables or disables writing to the depth buffer.\n   * @default true\n   */\n  get depthMask() {\n    return !!(this.data & 1 << DEPTH_MASK);\n  }\n  set depthMask(value) {\n    if (!!(this.data & 1 << DEPTH_MASK) !== value) {\n      this.data ^= 1 << DEPTH_MASK;\n    }\n  }\n  /**\n   * Specifies whether or not front or back-facing polygons can be culled.\n   * @default false\n   */\n  get clockwiseFrontFace() {\n    return !!(this.data & 1 << WINDING);\n  }\n  set clockwiseFrontFace(value) {\n    if (!!(this.data & 1 << WINDING) !== value) {\n      this.data ^= 1 << WINDING;\n    }\n  }\n  /**\n   * The blend mode to be applied when this state is set. Apply a value of `normal` to reset the blend mode.\n   * Setting this mode to anything other than NO_BLEND will automatically switch blending on.\n   * @default 'normal'\n   */\n  get blendMode() {\n    return this._blendMode;\n  }\n  set blendMode(value) {\n    this.blend = value !== \"none\";\n    this._blendMode = value;\n    this._blendModeId = blendModeIds[value] || 0;\n  }\n  /**\n   * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.\n   * @default 0\n   */\n  get polygonOffset() {\n    return this._polygonOffset;\n  }\n  set polygonOffset(value) {\n    this.offsets = !!value;\n    this._polygonOffset = value;\n  }\n  toString() {\n    return `[pixi.js/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`;\n  }\n  /**\n   * A quickly getting an instance of a State that is configured for 2d rendering.\n   * @returns a new State with values set for 2d rendering\n   */\n  static for2d() {\n    const state = new _State();\n    state.depthTest = false;\n    state.blend = true;\n    return state;\n  }\n};\n_State.default2d = _State.for2d();\nlet State = _State;\n\nexport { State };\n//# sourceMappingURL=State.mjs.map\n","\"use strict\";\nclass BatchableSprite {\n  constructor() {\n    this.batcherName = \"default\";\n    this.topology = \"triangle-list\";\n    // batch specific..\n    this.attributeSize = 4;\n    this.indexSize = 6;\n    this.packAsQuad = true;\n    this.roundPixels = 0;\n    this._attributeStart = 0;\n    // location in the buffer\n    this._batcher = null;\n    this._batch = null;\n  }\n  get blendMode() {\n    return this.renderable.groupBlendMode;\n  }\n  get color() {\n    return this.renderable.groupColorAlpha;\n  }\n  reset() {\n    this.renderable = null;\n    this.texture = null;\n    this._batcher = null;\n    this._batch = null;\n    this.bounds = null;\n  }\n  destroy() {\n  }\n}\n\nexport { BatchableSprite };\n//# sourceMappingURL=BatchableSprite.mjs.map\n","\"use strict\";\nconst tilingBit = {\n  name: \"tiling-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            uv = (tilingUniforms.uTextureTransform * vec3(uv, 1.0)).xy;\n\n            position = (position - tilingUniforms.uSizeAnchor.zw) * tilingUniforms.uSizeAnchor.xy;\n        `\n    )\n  },\n  fragment: {\n    header: (\n      /* wgsl */\n      `\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n\n            var coord = vUV + ceil(tilingUniforms.uClampOffset - vUV);\n            coord = (tilingUniforms.uMapCoord * vec3(coord, 1.0)).xy;\n            var unclamped = coord;\n            coord = clamp(coord, tilingUniforms.uClampFrame.xy, tilingUniforms.uClampFrame.zw);\n\n            var bias = 0.;\n\n            if(unclamped.x == coord.x && unclamped.y == coord.y)\n            {\n                bias = -32.;\n            }\n\n            outColor = textureSampleBias(uTexture, uSampler, coord, bias);\n        `\n    )\n  }\n};\nconst tilingBitGl = {\n  name: \"tiling-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n            uniform mat3 uTextureTransform;\n            uniform vec4 uSizeAnchor;\n\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            uv = (uTextureTransform * vec3(aUV, 1.0)).xy;\n\n            position = (position - uSizeAnchor.zw) * uSizeAnchor.xy;\n        `\n    )\n  },\n  fragment: {\n    header: (\n      /* glsl */\n      `\n            uniform sampler2D uTexture;\n            uniform mat3 uMapCoord;\n            uniform vec4 uClampFrame;\n            uniform vec2 uClampOffset;\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n\n        vec2 coord = vUV + ceil(uClampOffset - vUV);\n        coord = (uMapCoord * vec3(coord, 1.0)).xy;\n        vec2 unclamped = coord;\n        coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n        outColor = texture(uTexture, coord, unclamped == coord ? 0.0 : -32.0);// lod-bias very negative to force lod 0\n\n        `\n    )\n  }\n};\n\nexport { tilingBit, tilingBitGl };\n//# sourceMappingURL=tilingBit.mjs.map\n","import { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { compileHighShaderGpuProgram, compileHighShaderGlProgram } from '../../../rendering/high-shader/compileHighShaderToProgram.mjs';\nimport { localUniformBit, localUniformBitGl } from '../../../rendering/high-shader/shader-bits/localUniformBit.mjs';\nimport { roundPixelsBit, roundPixelsBitGl } from '../../../rendering/high-shader/shader-bits/roundPixelsBit.mjs';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader.mjs';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup.mjs';\nimport { Texture } from '../../../rendering/renderers/shared/texture/Texture.mjs';\nimport { tilingBit, tilingBitGl } from './tilingBit.mjs';\n\n\"use strict\";\nlet gpuProgram;\nlet glProgram;\nclass TilingSpriteShader extends Shader {\n  constructor() {\n    gpuProgram ?? (gpuProgram = compileHighShaderGpuProgram({\n      name: \"tiling-sprite-shader\",\n      bits: [\n        localUniformBit,\n        tilingBit,\n        roundPixelsBit\n      ]\n    }));\n    glProgram ?? (glProgram = compileHighShaderGlProgram({\n      name: \"tiling-sprite-shader\",\n      bits: [\n        localUniformBitGl,\n        tilingBitGl,\n        roundPixelsBitGl\n      ]\n    }));\n    const tilingUniforms = new UniformGroup({\n      uMapCoord: { value: new Matrix(), type: \"mat3x3<f32>\" },\n      uClampFrame: { value: new Float32Array([0, 0, 1, 1]), type: \"vec4<f32>\" },\n      uClampOffset: { value: new Float32Array([0, 0]), type: \"vec2<f32>\" },\n      uTextureTransform: { value: new Matrix(), type: \"mat3x3<f32>\" },\n      uSizeAnchor: { value: new Float32Array([100, 100, 0.5, 0.5]), type: \"vec4<f32>\" }\n    });\n    super({\n      glProgram,\n      gpuProgram,\n      resources: {\n        localUniforms: new UniformGroup({\n          uTransformMatrix: { value: new Matrix(), type: \"mat3x3<f32>\" },\n          uColor: { value: new Float32Array([1, 1, 1, 1]), type: \"vec4<f32>\" },\n          uRound: { value: 0, type: \"f32\" }\n        }),\n        tilingUniforms,\n        uTexture: Texture.EMPTY.source,\n        uSampler: Texture.EMPTY.source.style\n      }\n    });\n  }\n  updateUniforms(width, height, matrix, anchorX, anchorY, texture) {\n    const tilingUniforms = this.resources.tilingUniforms;\n    const textureWidth = texture.width;\n    const textureHeight = texture.height;\n    const textureMatrix = texture.textureMatrix;\n    const uTextureTransform = tilingUniforms.uniforms.uTextureTransform;\n    uTextureTransform.set(\n      matrix.a * textureWidth / width,\n      matrix.b * textureWidth / height,\n      matrix.c * textureHeight / width,\n      matrix.d * textureHeight / height,\n      matrix.tx / width,\n      matrix.ty / height\n    );\n    uTextureTransform.invert();\n    tilingUniforms.uniforms.uMapCoord = textureMatrix.mapCoord;\n    tilingUniforms.uniforms.uClampFrame = textureMatrix.uClampFrame;\n    tilingUniforms.uniforms.uClampOffset = textureMatrix.uClampOffset;\n    tilingUniforms.uniforms.uTextureTransform = uTextureTransform;\n    tilingUniforms.uniforms.uSizeAnchor[0] = width;\n    tilingUniforms.uniforms.uSizeAnchor[1] = height;\n    tilingUniforms.uniforms.uSizeAnchor[2] = anchorX;\n    tilingUniforms.uniforms.uSizeAnchor[3] = anchorY;\n    if (texture) {\n      this.resources.uTexture = texture.source;\n      this.resources.uSampler = texture.source.style;\n    }\n  }\n}\n\nexport { TilingSpriteShader };\n//# sourceMappingURL=TilingSpriteShader.mjs.map\n","import { MeshGeometry } from '../../mesh/shared/MeshGeometry.mjs';\n\n\"use strict\";\nclass QuadGeometry extends MeshGeometry {\n  constructor() {\n    super({\n      positions: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n      uvs: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n      indices: new Uint32Array([0, 1, 2, 0, 2, 3])\n    });\n  }\n}\n\nexport { QuadGeometry };\n//# sourceMappingURL=QuadGeometry.mjs.map\n","import { ExtensionType } from '../../extensions/Extensions.mjs';\nimport { getAdjustedBlendModeBlend } from '../../rendering/renderers/shared/state/getAdjustedBlendModeBlend.mjs';\nimport { State } from '../../rendering/renderers/shared/state/State.mjs';\nimport { RendererType } from '../../rendering/renderers/types.mjs';\nimport { color32BitToUniform } from '../graphics/gpu/colorToUniform.mjs';\nimport { BatchableMesh } from '../mesh/shared/BatchableMesh.mjs';\nimport { MeshGeometry } from '../mesh/shared/MeshGeometry.mjs';\nimport { TilingSpriteShader } from './shader/TilingSpriteShader.mjs';\nimport { QuadGeometry } from './utils/QuadGeometry.mjs';\nimport { setPositions } from './utils/setPositions.mjs';\nimport { setUvs } from './utils/setUvs.mjs';\n\n\"use strict\";\nconst sharedQuad = new QuadGeometry();\nclass TilingSpriteGpuData {\n  constructor() {\n    this.canBatch = true;\n    this.geometry = new MeshGeometry({\n      indices: sharedQuad.indices.slice(),\n      positions: sharedQuad.positions.slice(),\n      uvs: sharedQuad.uvs.slice()\n    });\n  }\n  destroy() {\n    this.geometry.destroy();\n    this.shader?.destroy();\n  }\n}\nclass TilingSpritePipe {\n  constructor(renderer) {\n    this._state = State.default2d;\n    this._renderer = renderer;\n  }\n  validateRenderable(renderable) {\n    const tilingSpriteData = this._getTilingSpriteData(renderable);\n    const couldBatch = tilingSpriteData.canBatch;\n    this._updateCanBatch(renderable);\n    const canBatch = tilingSpriteData.canBatch;\n    if (canBatch && canBatch === couldBatch) {\n      const { batchableMesh } = tilingSpriteData;\n      return !batchableMesh._batcher.checkAndUpdateTexture(\n        batchableMesh,\n        renderable.texture\n      );\n    }\n    return couldBatch !== canBatch;\n  }\n  addRenderable(tilingSprite, instructionSet) {\n    const batcher = this._renderer.renderPipes.batch;\n    this._updateCanBatch(tilingSprite);\n    const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n    const { geometry, canBatch } = tilingSpriteData;\n    if (canBatch) {\n      tilingSpriteData.batchableMesh || (tilingSpriteData.batchableMesh = new BatchableMesh());\n      const batchableMesh = tilingSpriteData.batchableMesh;\n      if (tilingSprite.didViewUpdate) {\n        this._updateBatchableMesh(tilingSprite);\n        batchableMesh.geometry = geometry;\n        batchableMesh.renderable = tilingSprite;\n        batchableMesh.transform = tilingSprite.groupTransform;\n        batchableMesh.setTexture(tilingSprite._texture);\n      }\n      batchableMesh.roundPixels = this._renderer._roundPixels | tilingSprite._roundPixels;\n      batcher.addToBatch(batchableMesh, instructionSet);\n    } else {\n      batcher.break(instructionSet);\n      tilingSpriteData.shader || (tilingSpriteData.shader = new TilingSpriteShader());\n      this.updateRenderable(tilingSprite);\n      instructionSet.add(tilingSprite);\n    }\n  }\n  execute(tilingSprite) {\n    const { shader } = this._getTilingSpriteData(tilingSprite);\n    shader.groups[0] = this._renderer.globalUniforms.bindGroup;\n    const localUniforms = shader.resources.localUniforms.uniforms;\n    localUniforms.uTransformMatrix = tilingSprite.groupTransform;\n    localUniforms.uRound = this._renderer._roundPixels | tilingSprite._roundPixels;\n    color32BitToUniform(\n      tilingSprite.groupColorAlpha,\n      localUniforms.uColor,\n      0\n    );\n    this._state.blendMode = getAdjustedBlendModeBlend(tilingSprite.groupBlendMode, tilingSprite.texture._source);\n    this._renderer.encoder.draw({\n      geometry: sharedQuad,\n      shader,\n      state: this._state\n    });\n  }\n  updateRenderable(tilingSprite) {\n    const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n    const { canBatch } = tilingSpriteData;\n    if (canBatch) {\n      const { batchableMesh } = tilingSpriteData;\n      if (tilingSprite.didViewUpdate)\n        this._updateBatchableMesh(tilingSprite);\n      batchableMesh._batcher.updateElement(batchableMesh);\n    } else if (tilingSprite.didViewUpdate) {\n      const { shader } = tilingSpriteData;\n      shader.updateUniforms(\n        tilingSprite.width,\n        tilingSprite.height,\n        tilingSprite._tileTransform.matrix,\n        tilingSprite.anchor.x,\n        tilingSprite.anchor.y,\n        tilingSprite.texture\n      );\n    }\n  }\n  _getTilingSpriteData(renderable) {\n    return renderable._gpuData[this._renderer.uid] || this._initTilingSpriteData(renderable);\n  }\n  _initTilingSpriteData(tilingSprite) {\n    const gpuData = new TilingSpriteGpuData();\n    gpuData.renderable = tilingSprite;\n    tilingSprite._gpuData[this._renderer.uid] = gpuData;\n    return gpuData;\n  }\n  _updateBatchableMesh(tilingSprite) {\n    const renderableData = this._getTilingSpriteData(tilingSprite);\n    const { geometry } = renderableData;\n    const style = tilingSprite.texture.source.style;\n    if (style.addressMode !== \"repeat\") {\n      style.addressMode = \"repeat\";\n      style.update();\n    }\n    setUvs(tilingSprite, geometry.uvs);\n    setPositions(tilingSprite, geometry.positions);\n  }\n  destroy() {\n    this._renderer = null;\n  }\n  _updateCanBatch(tilingSprite) {\n    const renderableData = this._getTilingSpriteData(tilingSprite);\n    const texture = tilingSprite.texture;\n    let _nonPowOf2wrapping = true;\n    if (this._renderer.type === RendererType.WEBGL) {\n      _nonPowOf2wrapping = this._renderer.context.supports.nonPowOf2wrapping;\n    }\n    renderableData.canBatch = texture.textureMatrix.isSimple && (_nonPowOf2wrapping || texture.source.isPowerOfTwo);\n    return renderableData.canBatch;\n  }\n}\n/** @ignore */\nTilingSpritePipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"tilingSprite\"\n};\n\nexport { TilingSpriteGpuData, TilingSpritePipe };\n//# sourceMappingURL=TilingSpritePipe.mjs.map\n","import { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { applyMatrix } from './applyMatrix.mjs';\n\n\"use strict\";\nfunction setUvs(tilingSprite, uvs) {\n  const texture = tilingSprite.texture;\n  const width = texture.frame.width;\n  const height = texture.frame.height;\n  let anchorX = 0;\n  let anchorY = 0;\n  if (tilingSprite.applyAnchorToTexture) {\n    anchorX = tilingSprite.anchor.x;\n    anchorY = tilingSprite.anchor.y;\n  }\n  uvs[0] = uvs[6] = -anchorX;\n  uvs[2] = uvs[4] = 1 - anchorX;\n  uvs[1] = uvs[3] = -anchorY;\n  uvs[5] = uvs[7] = 1 - anchorY;\n  const textureMatrix = Matrix.shared;\n  textureMatrix.copyFrom(tilingSprite._tileTransform.matrix);\n  textureMatrix.tx /= tilingSprite.width;\n  textureMatrix.ty /= tilingSprite.height;\n  textureMatrix.invert();\n  textureMatrix.scale(tilingSprite.width / width, tilingSprite.height / height);\n  applyMatrix(uvs, 2, 0, textureMatrix);\n}\n\nexport { setUvs };\n//# sourceMappingURL=setUvs.mjs.map\n","\"use strict\";\nfunction applyMatrix(array, stride, offset, matrix) {\n  let index = 0;\n  const size = array.length / (stride || 2);\n  const a = matrix.a;\n  const b = matrix.b;\n  const c = matrix.c;\n  const d = matrix.d;\n  const tx = matrix.tx;\n  const ty = matrix.ty;\n  offset *= stride;\n  while (index < size) {\n    const x = array[offset];\n    const y = array[offset + 1];\n    array[offset] = a * x + c * y + tx;\n    array[offset + 1] = b * x + d * y + ty;\n    offset += stride;\n    index++;\n  }\n}\n\nexport { applyMatrix };\n//# sourceMappingURL=applyMatrix.mjs.map\n","\"use strict\";\nfunction setPositions(tilingSprite, positions) {\n  const anchorX = tilingSprite.anchor.x;\n  const anchorY = tilingSprite.anchor.y;\n  positions[0] = -anchorX * tilingSprite.width;\n  positions[1] = -anchorY * tilingSprite.height;\n  positions[2] = (1 - anchorX) * tilingSprite.width;\n  positions[3] = -anchorY * tilingSprite.height;\n  positions[4] = (1 - anchorX) * tilingSprite.width;\n  positions[5] = (1 - anchorY) * tilingSprite.height;\n  positions[6] = -anchorX * tilingSprite.width;\n  positions[7] = (1 - anchorY) * tilingSprite.height;\n}\n\nexport { setPositions };\n//# sourceMappingURL=setPositions.mjs.map\n","import { extensions } from '../../extensions/Extensions.mjs';\nimport { TilingSpritePipe } from './TilingSpritePipe.mjs';\n\n\"use strict\";\nextensions.add(TilingSpritePipe);\n//# sourceMappingURL=init.mjs.map\n","\"use strict\";\nclass BatchableMesh {\n  constructor() {\n    this.batcherName = \"default\";\n    this.packAsQuad = false;\n    this.indexOffset = 0;\n    this.attributeOffset = 0;\n    this.roundPixels = 0;\n    this._batcher = null;\n    this._batch = null;\n    this._textureMatrixUpdateId = -1;\n    this._uvUpdateId = -1;\n  }\n  get blendMode() {\n    return this.renderable.groupBlendMode;\n  }\n  get topology() {\n    return this._topology || this.geometry.topology;\n  }\n  set topology(value) {\n    this._topology = value;\n  }\n  reset() {\n    this.renderable = null;\n    this.texture = null;\n    this._batcher = null;\n    this._batch = null;\n    this.geometry = null;\n    this._uvUpdateId = -1;\n    this._textureMatrixUpdateId = -1;\n  }\n  /**\n   * Sets the texture for the batchable mesh.\n   * As it does so, it resets the texture matrix update ID.\n   * this is to ensure that the texture matrix is recalculated when the uvs are referenced\n   * @param value - The texture to set.\n   */\n  setTexture(value) {\n    if (this.texture === value)\n      return;\n    this.texture = value;\n    this._textureMatrixUpdateId = -1;\n  }\n  get uvs() {\n    const geometry = this.geometry;\n    const uvBuffer = geometry.getBuffer(\"aUV\");\n    const uvs = uvBuffer.data;\n    let transformedUvs = uvs;\n    const textureMatrix = this.texture.textureMatrix;\n    if (!textureMatrix.isSimple) {\n      transformedUvs = this._transformedUvs;\n      if (this._textureMatrixUpdateId !== textureMatrix._updateID || this._uvUpdateId !== uvBuffer._updateID) {\n        if (!transformedUvs || transformedUvs.length < uvs.length) {\n          transformedUvs = this._transformedUvs = new Float32Array(uvs.length);\n        }\n        this._textureMatrixUpdateId = textureMatrix._updateID;\n        this._uvUpdateId = uvBuffer._updateID;\n        textureMatrix.multiplyUvs(uvs, transformedUvs);\n      }\n    }\n    return transformedUvs;\n  }\n  get positions() {\n    return this.geometry.positions;\n  }\n  get indices() {\n    return this.geometry.indices;\n  }\n  get color() {\n    return this.renderable.groupColorAlpha;\n  }\n  get groupTransform() {\n    return this.renderable.groupTransform;\n  }\n  get attributeSize() {\n    return this.geometry.positions.length / 2;\n  }\n  get indexSize() {\n    return this.geometry.indices.length;\n  }\n}\n\nexport { BatchableMesh };\n//# sourceMappingURL=BatchableMesh.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { State } from '../../../rendering/renderers/shared/state/State.mjs';\nimport { BigPool } from '../../../utils/pool/PoolGroup.mjs';\nimport { color32BitToUniform } from '../gpu/colorToUniform.mjs';\nimport { BatchableGraphics } from './BatchableGraphics.mjs';\n\n\"use strict\";\nclass GraphicsGpuData {\n  constructor() {\n    this.batches = [];\n    this.batched = false;\n  }\n  destroy() {\n    this.batches.forEach((batch) => {\n      BigPool.return(batch);\n    });\n    this.batches.length = 0;\n  }\n}\nclass GraphicsPipe {\n  constructor(renderer, adaptor) {\n    this.state = State.for2d();\n    this.renderer = renderer;\n    this._adaptor = adaptor;\n    this.renderer.runners.contextChange.add(this);\n  }\n  contextChange() {\n    this._adaptor.contextChange(this.renderer);\n  }\n  validateRenderable(graphics) {\n    const context = graphics.context;\n    const wasBatched = !!graphics._gpuData;\n    const gpuContext = this.renderer.graphicsContext.updateGpuContext(context);\n    if (gpuContext.isBatchable || wasBatched !== gpuContext.isBatchable) {\n      return true;\n    }\n    return false;\n  }\n  addRenderable(graphics, instructionSet) {\n    const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);\n    if (graphics.didViewUpdate) {\n      this._rebuild(graphics);\n    }\n    if (gpuContext.isBatchable) {\n      this._addToBatcher(graphics, instructionSet);\n    } else {\n      this.renderer.renderPipes.batch.break(instructionSet);\n      instructionSet.add(graphics);\n    }\n  }\n  updateRenderable(graphics) {\n    const gpuData = this._getGpuDataForRenderable(graphics);\n    const batches = gpuData.batches;\n    for (let i = 0; i < batches.length; i++) {\n      const batch = batches[i];\n      batch._batcher.updateElement(batch);\n    }\n  }\n  execute(graphics) {\n    if (!graphics.isRenderable)\n      return;\n    const renderer = this.renderer;\n    const context = graphics.context;\n    const contextSystem = renderer.graphicsContext;\n    if (!contextSystem.getGpuContext(context).batches.length) {\n      return;\n    }\n    const shader = context.customShader || this._adaptor.shader;\n    this.state.blendMode = graphics.groupBlendMode;\n    const localUniforms = shader.resources.localUniforms.uniforms;\n    localUniforms.uTransformMatrix = graphics.groupTransform;\n    localUniforms.uRound = renderer._roundPixels | graphics._roundPixels;\n    color32BitToUniform(\n      graphics.groupColorAlpha,\n      localUniforms.uColor,\n      0\n    );\n    this._adaptor.execute(this, graphics);\n  }\n  _rebuild(graphics) {\n    const gpuData = this._getGpuDataForRenderable(graphics);\n    const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);\n    gpuData.destroy();\n    if (gpuContext.isBatchable) {\n      this._updateBatchesForRenderable(graphics, gpuData);\n    }\n  }\n  _addToBatcher(graphics, instructionSet) {\n    const batchPipe = this.renderer.renderPipes.batch;\n    const batches = this._getGpuDataForRenderable(graphics).batches;\n    for (let i = 0; i < batches.length; i++) {\n      const batch = batches[i];\n      batchPipe.addToBatch(batch, instructionSet);\n    }\n  }\n  _getGpuDataForRenderable(graphics) {\n    return graphics._gpuData[this.renderer.uid] || this._initGpuDataForRenderable(graphics);\n  }\n  _initGpuDataForRenderable(graphics) {\n    const gpuData = new GraphicsGpuData();\n    graphics._gpuData[this.renderer.uid] = gpuData;\n    return gpuData;\n  }\n  _updateBatchesForRenderable(graphics, gpuData) {\n    const context = graphics.context;\n    const gpuContext = this.renderer.graphicsContext.getGpuContext(context);\n    const roundPixels = this.renderer._roundPixels | graphics._roundPixels;\n    gpuData.batches = gpuContext.batches.map((batch) => {\n      const batchClone = BigPool.get(BatchableGraphics);\n      batch.copyTo(batchClone);\n      batchClone.renderable = graphics;\n      batchClone.roundPixels = roundPixels;\n      return batchClone;\n    });\n  }\n  destroy() {\n    this.renderer = null;\n    this._adaptor.destroy();\n    this._adaptor = null;\n    this.state = null;\n  }\n}\n/** @ignore */\nGraphicsPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"graphics\"\n};\n\nexport { GraphicsGpuData, GraphicsPipe };\n//# sourceMappingURL=GraphicsPipe.mjs.map\n","import { extensions } from '../../extensions/Extensions.mjs';\nimport { GraphicsContextSystem } from './shared/GraphicsContextSystem.mjs';\nimport { GraphicsPipe } from './shared/GraphicsPipe.mjs';\n\n\"use strict\";\nextensions.add(GraphicsPipe);\nextensions.add(GraphicsContextSystem);\n//# sourceMappingURL=init.mjs.map\n","\"use strict\";\nclass GlParticleContainerAdaptor {\n  execute(particleContainerPipe, container) {\n    const state = particleContainerPipe.state;\n    const renderer = particleContainerPipe.renderer;\n    const shader = container.shader || particleContainerPipe.defaultShader;\n    shader.resources.uTexture = container.texture._source;\n    shader.resources.uniforms = particleContainerPipe.localUniforms;\n    const gl = renderer.gl;\n    const buffer = particleContainerPipe.getBuffers(container);\n    renderer.shader.bind(shader);\n    renderer.state.set(state);\n    renderer.geometry.bind(buffer.geometry, shader.glProgram);\n    const byteSize = buffer.geometry.indexBuffer.data.BYTES_PER_ELEMENT;\n    const glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;\n    gl.drawElements(gl.TRIANGLES, container.particleChildren.length * 6, glType, 0);\n  }\n}\n\nexport { GlParticleContainerAdaptor };\n//# sourceMappingURL=GlParticleContainerAdaptor.mjs.map\n","\"use strict\";\nfunction createIndicesForQuads(size, outBuffer = null) {\n  const totalIndices = size * 6;\n  if (totalIndices > 65535) {\n    outBuffer || (outBuffer = new Uint32Array(totalIndices));\n  } else {\n    outBuffer || (outBuffer = new Uint16Array(totalIndices));\n  }\n  if (outBuffer.length !== totalIndices) {\n    throw new Error(`Out buffer length is incorrect, got ${outBuffer.length} and expected ${totalIndices}`);\n  }\n  for (let i = 0, j = 0; i < totalIndices; i += 6, j += 4) {\n    outBuffer[i + 0] = j + 0;\n    outBuffer[i + 1] = j + 1;\n    outBuffer[i + 2] = j + 2;\n    outBuffer[i + 3] = j + 0;\n    outBuffer[i + 4] = j + 2;\n    outBuffer[i + 5] = j + 3;\n  }\n  return outBuffer;\n}\n\nexport { createIndicesForQuads };\n//# sourceMappingURL=createIndicesForQuads.mjs.map\n","import { getAttributeInfoFromFormat } from '../../../../rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.mjs';\n\n\"use strict\";\nfunction generateParticleUpdateFunction(properties) {\n  return {\n    dynamicUpdate: generateUpdateFunction(properties, true),\n    staticUpdate: generateUpdateFunction(properties, false)\n  };\n}\nfunction generateUpdateFunction(properties, dynamic) {\n  const funcFragments = [];\n  funcFragments.push(`\n\n        var index = 0;\n\n        for (let i = 0; i < ps.length; ++i)\n        {\n            const p = ps[i];\n\n            `);\n  let offset = 0;\n  for (const i in properties) {\n    const property = properties[i];\n    if (dynamic !== property.dynamic)\n      continue;\n    funcFragments.push(`offset = index + ${offset}`);\n    funcFragments.push(property.code);\n    const attributeInfo = getAttributeInfoFromFormat(property.format);\n    offset += attributeInfo.stride / 4;\n  }\n  funcFragments.push(`\n            index += stride * 4;\n        }\n    `);\n  funcFragments.unshift(`\n        var stride = ${offset};\n    `);\n  const functionSource = funcFragments.join(\"\\n\");\n  return new Function(\"ps\", \"f32v\", \"u32v\", functionSource);\n}\n\nexport { generateParticleUpdateFunction };\n//# sourceMappingURL=generateParticleUpdateFunction.mjs.map\n","import { Buffer } from '../../../rendering/renderers/shared/buffer/Buffer.mjs';\nimport { BufferUsage } from '../../../rendering/renderers/shared/buffer/const.mjs';\nimport { Geometry } from '../../../rendering/renderers/shared/geometry/Geometry.mjs';\nimport { getAttributeInfoFromFormat } from '../../../rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.mjs';\nimport { ViewableBuffer } from '../../../utils/data/ViewableBuffer.mjs';\nimport { createIndicesForQuads } from './utils/createIndicesForQuads.mjs';\nimport { generateParticleUpdateFunction } from './utils/generateParticleUpdateFunction.mjs';\n\n\"use strict\";\nclass ParticleBuffer {\n  constructor(options) {\n    this._size = 0;\n    this._generateParticleUpdateCache = {};\n    const size = this._size = options.size ?? 1e3;\n    const properties = options.properties;\n    let staticVertexSize = 0;\n    let dynamicVertexSize = 0;\n    for (const i in properties) {\n      const property = properties[i];\n      const attributeInfo = getAttributeInfoFromFormat(property.format);\n      if (property.dynamic) {\n        dynamicVertexSize += attributeInfo.stride;\n      } else {\n        staticVertexSize += attributeInfo.stride;\n      }\n    }\n    this._dynamicStride = dynamicVertexSize / 4;\n    this._staticStride = staticVertexSize / 4;\n    this.staticAttributeBuffer = new ViewableBuffer(size * 4 * staticVertexSize);\n    this.dynamicAttributeBuffer = new ViewableBuffer(size * 4 * dynamicVertexSize);\n    this.indexBuffer = createIndicesForQuads(size);\n    const geometry = new Geometry();\n    let dynamicOffset = 0;\n    let staticOffset = 0;\n    this._staticBuffer = new Buffer({\n      data: new Float32Array(1),\n      label: \"static-particle-buffer\",\n      shrinkToFit: false,\n      usage: BufferUsage.VERTEX | BufferUsage.COPY_DST\n    });\n    this._dynamicBuffer = new Buffer({\n      data: new Float32Array(1),\n      label: \"dynamic-particle-buffer\",\n      shrinkToFit: false,\n      usage: BufferUsage.VERTEX | BufferUsage.COPY_DST\n    });\n    for (const i in properties) {\n      const property = properties[i];\n      const attributeInfo = getAttributeInfoFromFormat(property.format);\n      if (property.dynamic) {\n        geometry.addAttribute(property.attributeName, {\n          buffer: this._dynamicBuffer,\n          stride: this._dynamicStride * 4,\n          offset: dynamicOffset * 4,\n          format: property.format\n        });\n        dynamicOffset += attributeInfo.size;\n      } else {\n        geometry.addAttribute(property.attributeName, {\n          buffer: this._staticBuffer,\n          stride: this._staticStride * 4,\n          offset: staticOffset * 4,\n          format: property.format\n        });\n        staticOffset += attributeInfo.size;\n      }\n    }\n    geometry.addIndex(this.indexBuffer);\n    const uploadFunction = this.getParticleUpdate(properties);\n    this._dynamicUpload = uploadFunction.dynamicUpdate;\n    this._staticUpload = uploadFunction.staticUpdate;\n    this.geometry = geometry;\n  }\n  getParticleUpdate(properties) {\n    const key = getParticleSyncKey(properties);\n    if (this._generateParticleUpdateCache[key]) {\n      return this._generateParticleUpdateCache[key];\n    }\n    this._generateParticleUpdateCache[key] = this.generateParticleUpdate(properties);\n    return this._generateParticleUpdateCache[key];\n  }\n  generateParticleUpdate(properties) {\n    return generateParticleUpdateFunction(properties);\n  }\n  update(particles, uploadStatic) {\n    if (particles.length > this._size) {\n      uploadStatic = true;\n      this._size = Math.max(particles.length, this._size * 1.5 | 0);\n      this.staticAttributeBuffer = new ViewableBuffer(this._size * this._staticStride * 4 * 4);\n      this.dynamicAttributeBuffer = new ViewableBuffer(this._size * this._dynamicStride * 4 * 4);\n      this.indexBuffer = createIndicesForQuads(this._size);\n      this.geometry.indexBuffer.setDataWithSize(\n        this.indexBuffer,\n        this.indexBuffer.byteLength,\n        true\n      );\n    }\n    const dynamicAttributeBuffer = this.dynamicAttributeBuffer;\n    this._dynamicUpload(particles, dynamicAttributeBuffer.float32View, dynamicAttributeBuffer.uint32View);\n    this._dynamicBuffer.setDataWithSize(\n      this.dynamicAttributeBuffer.float32View,\n      particles.length * this._dynamicStride * 4,\n      true\n    );\n    if (uploadStatic) {\n      const staticAttributeBuffer = this.staticAttributeBuffer;\n      this._staticUpload(particles, staticAttributeBuffer.float32View, staticAttributeBuffer.uint32View);\n      this._staticBuffer.setDataWithSize(\n        staticAttributeBuffer.float32View,\n        particles.length * this._staticStride * 4,\n        true\n      );\n    }\n  }\n  destroy() {\n    this._staticBuffer.destroy();\n    this._dynamicBuffer.destroy();\n    this.geometry.destroy();\n  }\n}\nfunction getParticleSyncKey(properties) {\n  const keyGen = [];\n  for (const key in properties) {\n    const property = properties[key];\n    keyGen.push(key, property.code, property.dynamic ? \"d\" : \"s\");\n  }\n  return keyGen.join(\"_\");\n}\n\nexport { ParticleBuffer };\n//# sourceMappingURL=ParticleBuffer.mjs.map\n","var wgsl = \"\\nstruct ParticleUniforms {\\n  uProjectionMatrix:mat3x3<f32>,\\n  uColor:vec4<f32>,\\n  uResolution:vec2<f32>,\\n  uRoundPixels:f32,\\n};\\n\\n@group(0) @binding(0) var<uniform> uniforms: ParticleUniforms;\\n\\n@group(1) @binding(0) var uTexture: texture_2d<f32>;\\n@group(1) @binding(1) var uSampler : sampler;\\n\\nstruct VSOutput {\\n    @builtin(position) position: vec4<f32>,\\n    @location(0) uv : vec2<f32>,\\n    @location(1) color : vec4<f32>,\\n  };\\n@vertex\\nfn mainVertex(\\n  @location(0) aVertex: vec2<f32>,\\n  @location(1) aPosition: vec2<f32>,\\n  @location(2) aUV: vec2<f32>,\\n  @location(3) aColor: vec4<f32>,\\n  @location(4) aRotation: f32,\\n) -> VSOutput {\\n  \\n   let v = vec2(\\n       aVertex.x * cos(aRotation) - aVertex.y * sin(aRotation),\\n       aVertex.x * sin(aRotation) + aVertex.y * cos(aRotation)\\n   ) + aPosition;\\n\\n   let position = vec4((uniforms.uProjectionMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\\n\\n    let vColor = vec4(aColor.rgb * aColor.a, aColor.a) * uniforms.uColor;\\n\\n  return VSOutput(\\n   position,\\n   aUV,\\n   vColor,\\n  );\\n}\\n\\n@fragment\\nfn mainFragment(\\n  @location(0) uv: vec2<f32>,\\n  @location(1) color: vec4<f32>,\\n  @builtin(position) position: vec4<f32>,\\n) -> @location(0) vec4<f32> {\\n\\n    var sample = textureSample(uTexture, uSampler, uv) * color;\\n   \\n    return sample;\\n}\";\n\nexport { wgsl as default };\n//# sourceMappingURL=particles.wgsl.mjs.map\n","import { Color } from '../../../../color/Color.mjs';\nimport { Matrix } from '../../../../maths/matrix/Matrix.mjs';\nimport { GlProgram } from '../../../../rendering/renderers/gl/shader/GlProgram.mjs';\nimport { GpuProgram } from '../../../../rendering/renderers/gpu/shader/GpuProgram.mjs';\nimport { Shader } from '../../../../rendering/renderers/shared/shader/Shader.mjs';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture.mjs';\nimport { TextureStyle } from '../../../../rendering/renderers/shared/texture/TextureStyle.mjs';\nimport fragment from './particles.frag.mjs';\nimport vertex from './particles.vert.mjs';\nimport wgsl from './particles.wgsl.mjs';\n\n\"use strict\";\nclass ParticleShader extends Shader {\n  constructor() {\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment\n    });\n    const gpuProgram = GpuProgram.from({\n      fragment: {\n        source: wgsl,\n        entryPoint: \"mainFragment\"\n      },\n      vertex: {\n        source: wgsl,\n        entryPoint: \"mainVertex\"\n      }\n    });\n    super({\n      glProgram,\n      gpuProgram,\n      resources: {\n        // this will be replaced with the texture from the particle container\n        uTexture: Texture.WHITE.source,\n        // this will be replaced with the texture style from the particle container\n        uSampler: new TextureStyle({}),\n        // this will be replaced with the local uniforms from the particle container\n        uniforms: {\n          uTranslationMatrix: { value: new Matrix(), type: \"mat3x3<f32>\" },\n          uColor: { value: new Color(16777215), type: \"vec4<f32>\" },\n          uRound: { value: 1, type: \"f32\" },\n          uResolution: { value: [0, 0], type: \"vec2<f32>\" }\n        }\n      }\n    });\n  }\n}\n\nexport { ParticleShader };\n//# sourceMappingURL=ParticleShader.mjs.map\n","var vertex = \"attribute vec2 aVertex;\\nattribute vec2 aUV;\\nattribute vec4 aColor;\\n\\nattribute vec2 aPosition;\\nattribute float aRotation;\\n\\nuniform mat3 uTranslationMatrix;\\nuniform float uRound;\\nuniform vec2 uResolution;\\nuniform vec4 uColor;\\n\\nvarying vec2 vUV;\\nvarying vec4 vColor;\\n\\nvec2 roundPixels(vec2 position, vec2 targetSize)\\n{       \\n    return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\\n}\\n\\nvoid main(void){\\n    float cosRotation = cos(aRotation);\\n    float sinRotation = sin(aRotation);\\n    float x = aVertex.x * cosRotation - aVertex.y * sinRotation;\\n    float y = aVertex.x * sinRotation + aVertex.y * cosRotation;\\n\\n    vec2 v = vec2(x, y);\\n    v = v + aPosition;\\n\\n    gl_Position = vec4((uTranslationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\\n\\n    if(uRound == 1.0)\\n    {\\n        gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\\n    }\\n\\n    vUV = aUV;\\n    vColor = vec4(aColor.rgb * aColor.a, aColor.a) * uColor;\\n}\\n\";\n\nexport { vertex as default };\n//# sourceMappingURL=particles.vert.mjs.map\n","var fragment = \"varying vec2 vUV;\\nvarying vec4 vColor;\\n\\nuniform sampler2D uTexture;\\n\\nvoid main(void){\\n    vec4 color = texture2D(uTexture, vUV) * vColor;\\n    gl_FragColor = color;\\n}\";\n\nexport { fragment as default };\n//# sourceMappingURL=particles.frag.mjs.map\n","import { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup.mjs';\nimport { getAdjustedBlendModeBlend } from '../../../rendering/renderers/shared/state/getAdjustedBlendModeBlend.mjs';\nimport { State } from '../../../rendering/renderers/shared/state/State.mjs';\nimport { color32BitToUniform } from '../../graphics/gpu/colorToUniform.mjs';\nimport { ParticleBuffer } from './ParticleBuffer.mjs';\nimport { ParticleShader } from './shader/ParticleShader.mjs';\n\n\"use strict\";\nclass ParticleContainerPipe {\n  /**\n   * @param renderer - The renderer this sprite batch works for.\n   * @param adaptor\n   */\n  constructor(renderer, adaptor) {\n    /** @internal */\n    this.state = State.for2d();\n    /** Local uniforms that are used for rendering particles. */\n    this.localUniforms = new UniformGroup({\n      uTranslationMatrix: { value: new Matrix(), type: \"mat3x3<f32>\" },\n      uColor: { value: new Float32Array(4), type: \"vec4<f32>\" },\n      uRound: { value: 1, type: \"f32\" },\n      uResolution: { value: [0, 0], type: \"vec2<f32>\" }\n    });\n    this.renderer = renderer;\n    this.adaptor = adaptor;\n    this.defaultShader = new ParticleShader();\n    this.state = State.for2d();\n  }\n  validateRenderable(_renderable) {\n    return false;\n  }\n  addRenderable(renderable, instructionSet) {\n    this.renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add(renderable);\n  }\n  getBuffers(renderable) {\n    return renderable._gpuData[this.renderer.uid] || this._initBuffer(renderable);\n  }\n  _initBuffer(renderable) {\n    renderable._gpuData[this.renderer.uid] = new ParticleBuffer({\n      size: renderable.particleChildren.length,\n      properties: renderable._properties\n    });\n    return renderable._gpuData[this.renderer.uid];\n  }\n  updateRenderable(_renderable) {\n  }\n  execute(container) {\n    const children = container.particleChildren;\n    if (children.length === 0) {\n      return;\n    }\n    const renderer = this.renderer;\n    const buffer = this.getBuffers(container);\n    container.texture || (container.texture = children[0].texture);\n    const state = this.state;\n    buffer.update(children, container._childrenDirty);\n    container._childrenDirty = false;\n    state.blendMode = getAdjustedBlendModeBlend(container.blendMode, container.texture._source);\n    const uniforms = this.localUniforms.uniforms;\n    const transformationMatrix = uniforms.uTranslationMatrix;\n    container.worldTransform.copyTo(transformationMatrix);\n    transformationMatrix.prepend(renderer.globalUniforms.globalUniformData.projectionMatrix);\n    uniforms.uResolution = renderer.globalUniforms.globalUniformData.resolution;\n    uniforms.uRound = renderer._roundPixels | container._roundPixels;\n    color32BitToUniform(\n      container.groupColorAlpha,\n      uniforms.uColor,\n      0\n    );\n    this.adaptor.execute(this, container);\n  }\n  /** Destroys the ParticleRenderer. */\n  destroy() {\n    if (this.defaultShader) {\n      this.defaultShader.destroy();\n      this.defaultShader = null;\n    }\n  }\n}\n\nexport { ParticleContainerPipe };\n//# sourceMappingURL=ParticleContainerPipe.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { GlParticleContainerAdaptor } from '../gl/GlParticleContainerAdaptor.mjs';\nimport { ParticleContainerPipe } from './ParticleContainerPipe.mjs';\n\n\"use strict\";\nclass GlParticleContainerPipe extends ParticleContainerPipe {\n  constructor(renderer) {\n    super(renderer, new GlParticleContainerAdaptor());\n  }\n}\n/** @ignore */\nGlParticleContainerPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes\n  ],\n  name: \"particle\"\n};\n\nexport { GlParticleContainerPipe };\n//# sourceMappingURL=GlParticleContainerPipe.mjs.map\n","\"use strict\";\nclass GpuParticleContainerAdaptor {\n  execute(particleContainerPipe, container) {\n    const renderer = particleContainerPipe.renderer;\n    const shader = container.shader || particleContainerPipe.defaultShader;\n    shader.groups[0] = renderer.renderPipes.uniformBatch.getUniformBindGroup(particleContainerPipe.localUniforms, true);\n    shader.groups[1] = renderer.texture.getTextureBindGroup(container.texture);\n    const state = particleContainerPipe.state;\n    const buffer = particleContainerPipe.getBuffers(container);\n    renderer.encoder.draw({\n      geometry: buffer.geometry,\n      shader: container.shader || particleContainerPipe.defaultShader,\n      state,\n      size: container.particleChildren.length * 6\n    });\n  }\n}\n\nexport { GpuParticleContainerAdaptor };\n//# sourceMappingURL=GpuParticleContainerAdaptor.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { GpuParticleContainerAdaptor } from '../gpu/GpuParticleContainerAdaptor.mjs';\nimport { ParticleContainerPipe } from './ParticleContainerPipe.mjs';\n\n\"use strict\";\nclass GpuParticleContainerPipe extends ParticleContainerPipe {\n  constructor(renderer) {\n    super(renderer, new GpuParticleContainerAdaptor());\n  }\n}\n/** @ignore */\nGpuParticleContainerPipe.extension = {\n  type: [\n    ExtensionType.WebGPUPipes\n  ],\n  name: \"particle\"\n};\n\nexport { GpuParticleContainerPipe };\n//# sourceMappingURL=GpuParticleContainerPipe.mjs.map\n","import { extensions } from '../../extensions/Extensions.mjs';\nimport { GlParticleContainerPipe } from './shared/GlParticleContainerPipe.mjs';\nimport { GpuParticleContainerPipe } from './shared/GpuParticleContainerPipe.mjs';\n\n\"use strict\";\nextensions.add(GlParticleContainerPipe);\nextensions.add(GpuParticleContainerPipe);\n//# sourceMappingURL=init.mjs.map\n"],"names":["localUniformBit","name","vertex","header","main","end","localUniformBitGroup2","replace","localUniformBitGl","BatchableText","BatchableSprite","constructor","renderer","super","this","_renderer","runners","resolutionChange","add","text","renderable","_autoResolution","onViewUpdate","destroy","canvasText","returnTexture","texture","CanvasTextPipe","validateRenderable","_didTextUpdate","addRenderable","instructionSet","batchableText","_getGpuText","_updateGpuText","renderPipes","batch","addToBatch","updateRenderable","_batcher","updateElement","_resolution","resolution","getTexture","updateTextBounds","_gpuData","uid","initGpuText","transform","groupTransform","bounds","minX","maxX","minY","maxY","roundPixels","_roundPixels","extension","type","WebGLPipes","WebGPUPipes","CanvasPipes","CanvasTextSystem","options","_style","_textKey","deprecation","style","TextStyle","textureStyle","TextureStyle","toString","frame","canvasAndContext","CanvasTextGenerator","getCanvasAndContext","getPo2TextureFromSource","canvas","width","height","source","trim","pad","padding","copyFrom","scale","updateUvs","filters","filteredTexture","_applyFilters","returnCanvasAndContext","initSource","_source","resource","uploadMethodId","alphaMode","TexturePool","renderTextToCanvas","currentRenderTarget","renderTarget","resultTexture","filter","generateFilteredTexture","bind","WebGLSystem","WebGPUSystem","CanvasSystem","batchableSprite","_getFinalPadding","_anchor","paddingOffset","_x","paddingOffsetY","_y","tempBounds","image","getOptimalTexture","emit","BatchableHTMLText","generatingTexture","htmlText","returnTexturePromise","texturePromise","HTMLTextPipe","batchableHTMLText","catch","e","console","error","getTexturePromise","renderGroup","parentRenderGroup","structureDidChange","Texture","EMPTY","nssvg","nsxhtml","HTMLTextRenderData","svgRoot","document","createElementNS","foreignObject","domElement","styleElement","setAttribute","overflow","appendChild","get","createImage","FontStylePromiseCache","Map","tempHTMLTextRenderData","HTMLTextSystem","_createCanvas","WEBGPU","_buildTexturePromise","htmlTextData","fontFamilies","fontFamily","dedupe","matches","match","addFontFamily","fontFamily2","push","Array","isArray","i","length","forEach","split","tagStyles","extractFontFamilies","fontCSS","async","fontPromises","Cache","has","map","entries","promises","entry","url","out","faces","face","weight","dataSrc","response","fetch","blob","reader","FileReader","Promise","resolve","reject","onloadend","result","onerror","readAsDataURL","loadFontAsBase64","fontWeight","fontStyle","loadFontCSS","set","all","then","css","join","getFontCss","measured","fontStyleCSS","htmlTextRenderData","innerHTML","cssStyle","textContent","body","contentBounds","getBoundingClientRect","remove","doublePadding","measureHtmlText","Math","ceil","max","svgURL","XMLSerializer","serializeToString","getSVGUrl","delay","resolve2","setTimeout","onload","src","encodeURIComponent","crossOrigin","loadSVGImage","userAgent","getNavigator","test","isSafari","CanvasPool","getOptimalCanvasAndContext","context","clearRect","drawImage","getTemporaryCanvasFromImage","return","_cleanUp","warn","color32BitToUniform","abgr","offset","alpha","ResizePlugin","init","Object","defineProperty","dom","globalThis","removeEventListener","queueResize","_resizeTo","addEventListener","resize","_cancelResize","_resizeId","requestAnimationFrame","cancelAnimationFrame","window","innerWidth","innerHeight","clientWidth","clientHeight","render","resizeTo","Application","TickerPlugin","assign","autoStart","sharedTicker","ticker","_ticker","LOW","stop","start","Ticker","shared","oldTicker","FilterPipe","filterEffect","container","break","renderPipeId","canBundle","action","pop","_filterEffect","_container","execute","instruction","quadGeometry","Geometry","attributes","aPosition","buffer","Float32Array","format","stride","indexBuffer","Uint32Array","FilterData","skip","inputTexture","backTexture","Bounds","blendRequired","outputRenderSurface","globalFrame","x","y","FilterSystem","_filterStackIndex","_filterStack","_filterGlobalUniforms","UniformGroup","uInputSize","value","uInputPixel","uInputClamp","uOutputFrame","uGlobalFrame","uOutputTexture","_globalFilterBindGroup","BindGroup","activeBackTexture","_activeFilterData","filterData","_pushFilterData","renderSurface","colorTextureSource","colorTexture","rootResolution","rootAntialias","antialias","_calculateFilterArea","_calculateFilterBounds","rootViewPort","previousFilterData","_getPreviousFilterData","globalResolution","_findFilterResolution","offsetX","offsetY","_calculateGlobalFrame","_setupFilterTextures","addRect","rectangle","finishRenderPass","_applyFiltersToTexture","outputTexture","_popFilterData","globalUniforms","getBackTexture","lastRenderSurface","previousBounds","backgroundResolution","floor","copyToTexture","applyFilter","input","output","clear","isFinalTarget","rootRenderTarget","_findPreviousFilterOffset","_updateFilterUniforms","_setupBindGroupsAndRender","calculateSpriteMatrix","outputMatrix","sprite","data","mappedMatrix","worldTransform","copyTo","Matrix","cacheToLocalTransform","prepend","invert","orig","translate","anchor","uniformBatch","batchUniforms","getUboResource","setResource","groups","encoder","draw","geometry","shader","state","_state","topology","WEBGL","getRenderTarget","sourceWidth","sourceHeight","uniforms","outputFrame","inputSize","inputPixel","inputClamp","pixelWidth","pixelHeight","rootTexture","isRoot","update","currentIndex","lastIndex","prevFilterData","renderables","tempMatrix","matrix","globalDisplayStatus","addBounds","getGlobalRenderableBounds","filterArea","applyMatrix","getFastGlobalBounds","filterFrameTransform","apply","flip","tempTexture","flop","t","viewPort","paddingMultiplier","Infinity","enabled","clipToViewport","min","compatibleRenderers","backBuffer","useBackBuffer","fitBounds","isPositive","index","_MeshGeometry","args","positions","uvs","indices","defaultOptions","shrinkToFit","shrinkBuffersToFit","label","usage","VERTEX","COPY_DST","aUV","INDEX","batchMode","MeshGeometry","MeshGpuData","MeshPipe","adaptor","localUniforms","uTransformMatrix","uColor","uRound","localUniformsBindGroup","_adaptor","mesh","meshData","_getMeshData","wasBatched","batched","isBatched","_geometry","indexSize","vertexSize","batchableMesh","_getBatchableMesh","_texture","_textureMatrixUpdateId","checkAndUpdateTexture","batcher","didViewUpdate","gpuBatchableMesh","setTexture","isRenderable","blendMode","getAdjustedBlendModeBlend","groupBlendMode","groupColorAlpha","_a","_b","_initMeshData","_initBatchableMesh","gpuMesh","BatchableMesh","localUniformMSDFBit","fragment","localUniformMSDFBitGl","mSDFBit","mSDFBitGl","gpuProgram","glProgram","SdfShader","Shader","maxTextures","uDistance","bits","colorBit","generateTextureBatchBit","roundPixelsBit","resources","batchSamplers","getBatchSamplersUniformGroup","BitmapTextGraphics","Graphics","customShader","BitmapTextPipe","renderableGC","addManagedHash","bitmapText","graphicsRenderable","_getGpuBitmapText","graphics","syncWithProxy","_updateContext","_updateDistanceField","proxyGraphics","bitmapFont","BitmapFontManager","getFont","distanceField","limits","maxBatchableTextures","chars","CanvasTextMetrics","graphemeSegmenter","currentY","baseLineOffset","bitmapTextLayout","getBitmapTextLayout","tx","ty","_stroke","tint","applyFillAsTint","_fill","color","fontSize","fontMetrics","lineHeight","linePositionYShift","lines","line","j","charPositions","char","charData","round","xOffset","yOffset","proxyRenderable","dynamicFont","a","b","c","d","dx","sqrt","dy","worldScale","abs","fontScale","baseRenderedFontSize","distance","range","proxy","groupColor","localDisplayStatus","groupAlpha","_PlaneGeometry","verticesX","verticesY","build","total","verts","sizeX","sizeY","totalSub","xpos","ypos","value2","value3","value4","buffers","PlaneGeometry","_NineSliceGeometry","_originalWidth","originalWidth","_originalHeight","originalHeight","_leftWidth","leftWidth","_rightWidth","rightWidth","_topHeight","topHeight","_bottomHeight","bottomHeight","_anchorX","_anchorY","updatePositions","p","w","scaleW","h","scaleH","anchorOffsetX","anchorOffsetY","getBuffer","_uvw","_uvh","NineSliceGeometry","NineSliceSpriteGpuData","NineSliceSpritePipe","gpuSprite","_getGpuSprite","_updateBatchableSprite","_initGPUSprite","gpuData","blendModeIds","normal","multiply","screen","overlay","erase","_State","polygonOffset","blend","depthMask","offsets","cullMode","culling","clockwiseFrontFace","depthTest","_blendMode","_blendModeId","_polygonOffset","for2d","default2d","State","batcherName","attributeSize","packAsQuad","_attributeStart","_batch","reset","tilingBit","tilingBitGl","TilingSpriteShader","tilingUniforms","uMapCoord","uClampFrame","uClampOffset","uTextureTransform","uSizeAnchor","uTexture","uSampler","updateUniforms","anchorX","anchorY","textureWidth","textureHeight","textureMatrix","mapCoord","QuadGeometry","sharedQuad","TilingSpriteGpuData","canBatch","slice","TilingSpritePipe","tilingSpriteData","_getTilingSpriteData","couldBatch","_updateCanBatch","tilingSprite","_updateBatchableMesh","bindGroup","_tileTransform","_initTilingSpriteData","renderableData","addressMode","applyAnchorToTexture","array","size","setUvs","setPositions","_nonPowOf2wrapping","supports","nonPowOf2wrapping","isSimple","isPowerOfTwo","indexOffset","attributeOffset","_uvUpdateId","_topology","uvBuffer","transformedUvs","_transformedUvs","_updateID","multiplyUvs","GraphicsGpuData","batches","GraphicsPipe","contextChange","gpuContext","graphicsContext","updateGpuContext","isBatchable","_rebuild","_addToBatcher","_getGpuDataForRenderable","getGpuContext","_updateBatchesForRenderable","batchPipe","_initGpuDataForRenderable","batchClone","BatchableGraphics","GraphicsContextSystem","GlParticleContainerAdaptor","particleContainerPipe","defaultShader","gl","getBuffers","glType","BYTES_PER_ELEMENT","UNSIGNED_SHORT","UNSIGNED_INT","drawElements","TRIANGLES","particleChildren","createIndicesForQuads","outBuffer","totalIndices","Uint16Array","Error","generateUpdateFunction","properties","dynamic","funcFragments","property","code","getAttributeInfoFromFormat","unshift","functionSource","Function","ParticleBuffer","_size","_generateParticleUpdateCache","staticVertexSize","dynamicVertexSize","attributeInfo","_dynamicStride","_staticStride","staticAttributeBuffer","ViewableBuffer","dynamicAttributeBuffer","dynamicOffset","staticOffset","_staticBuffer","Buffer","_dynamicBuffer","addAttribute","attributeName","addIndex","uploadFunction","getParticleUpdate","_dynamicUpload","dynamicUpdate","_staticUpload","staticUpdate","key","keyGen","getParticleSyncKey","generateParticleUpdate","generateParticleUpdateFunction","particles","uploadStatic","setDataWithSize","byteLength","float32View","uint32View","wgsl","ParticleShader","GlProgram","from","GpuProgram","entryPoint","WHITE","uTranslationMatrix","Color","uResolution","ParticleContainerPipe","_renderable","_initBuffer","_properties","children","_childrenDirty","transformationMatrix","globalUniformData","projectionMatrix","GlParticleContainerPipe","GpuParticleContainerAdaptor","getUniformBindGroup","getTextureBindGroup","GpuParticleContainerPipe"],"sourceRoot":""}